[{"title":"web性能优化","url":"/2021/01/03/web性能优化/","tags":["性能优化"],"categories":["前端"]},{"title":"vue单页面应用白屏屏优化","url":"/2020/12/27/vue单页面应用白屏屏优化/","content":"\n## 什么是单页面应用（SPA)？\n\nvue 单页面应用使前端开发更加快捷、方便。**何谓单页面应用（SPA)**？\n\n**单页面**应用是指**只有一个主页面**的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。在交互的时候由路由程序动态载入，单页面的页面跳转，仅局部刷新。\n\n**多页面**应用（MPA）是指有多个页面的应用，页面跳转时是整页刷新。\n\n## 单页面应用的优缺点\n\n### 优点：\n\n1. 页面跳转快而流畅，可添加转场效果，局部刷新用户体验较好。\n2. 前后端分离，组件化开发，易复用，易维护。\n3. 页面跳转基于前端路由，对服务器压力较小。\n\n### 缺点\n\n1. 首页加载仅一个空标签，对**SEO 不友好**。\n2. 页面基于 js 渲染，弱网环境下，首页加载时间长，会出现**白屏问题**。\n3. 页面导航需要自行实现，页面的复杂度较高，需要一定的开发成本。\n\n## 单页面应用 SEO 和白屏优化\n\n我们可以通过按需加载、gzip 压缩等方法缓解单页面应用 js 包过大问题。但是解决白屏优化主要有以下三种方法：\n\n1. **骨架屏** (优化白屏问题)\n2. **预渲染** (preRender 优化 SEO)\n3. **服务端渲染**（ssr 优化白屏问题和 SEO)\n","tags":["性能优化"],"categories":["vue"]},{"title":"逸辰音乐问题点","url":"/2020/12/26/逸辰音乐问题点/","content":"\n今天在重构自己的项目时，发现了不少问题。总结归纳一下， 以便提高自己。\n\n## 一、在 vue 项目现有的 stylus 代码中添加新的样式无效\n\n在重构旧项目的过程中，我需要在现有 stylus 样式中添加一些 css。但是在添加 css 后，发现新样式不仅没有生效，反而会影响原有的样式。绞尽脑汁，最后发现是**stylus 缩进的格式**有问题。stylus 写法有很多种，常见的写法有 **{}** 或者**缩进**。当使用缩进写法时，**空格和 tab 不能混用**，否则会造成编译错误。\n![stylus](./images/stylus_bug_reason.png)\n\n## 二、多个 jsonp 请求问题\n\n使用 jsonp 库**同时发送多个 jsonp**请求时，要保证 **callback 参数各不相同**，否则会导致 data 解析失败。\n\n## 三、页面刷新 vuex 数据丢失\n\n在项目中，我们很多时候不可避免的会使用 vuex 来管理全局状态。vuex 状态是保存在**运行时内存**中的。当**F5**页面刷新时，vuex 会被**新建并初始化**，这就导致了数据丢失。常用的解决办法就是借助 **sessionStorage** 或者 **localStorage** 缓存 vuex 中重要的数据。\n\n```\n//  in state.ts\nconst sessionDisc = window.sessionStorage.getItem(\"disc\")\nconst state: any = {\n  disc: sessionDisc ? JSON.parse(sessionDisc) : {},\n}\n\n//  in mutations.ts\n  [types.SET_DISC](state: any, cd: any) {\n    state.disc = cd\n    window.sessionStorage.setItem(\"disc\", JSON.stringify(cd))\n  },\n```\n","categories":["前端"]},{"title":"造轮子遇到的问题","url":"/2020/12/24/造轮子遇到的问题/","content":"\n在 vue3 造轮子的过程中，我遇到了很多问题，这都是在平时在写业务代码时不常见的知识点。在写业务代码时，我主要关注的是**业务逻辑**，写出的代码质量相对不高。而在造轮子的过程中，我需要去抽象各种组件，会遇到各种形形色色的问题。总结归纳有助于不断的提高自己。\n\n### 一、 使用 BackTop 组件传递 target（滚动容器）\n\n当我们浏览 web 页面过长时，手动滚动回顶部需要的时间较长，这时可能就需要**返回页面顶部**的操作按钮。所以我就自己写了一个 BackTop 组件，该组件的具体用法[见文档](https://cai4633.gitee.io/mom-ui-doc/#/doc/backtop)。BackTop 组件使用时需要传递一个 target，这个参数是被监视滚动事件的元素，默认是 document。\n一开始，我设计的是直接传递一个 ELEMENT_NODE 给 target。但在实际运行时，发现会报错。因为在**ELEMENT_NODE**被传递过来时，**ELEMENT_NODE 不一定已经被渲染**。\n\n解决这个问题的方法很经典：**使用函数延迟代码执行**。我不再直接传递 ELEMENT_NODE ， 而是传递一个函数给 target。 该**函数的返回值是一个 ELEMENT_NODE** 。这样当我在 BackTop 组件 onMounted()时调用这个函数就可以适时的获取想要的 target。\n","tags":["Vue3"],"categories":["Vue"]},{"title":"ES6 常用知识点","url":"/2020/12/16/ES6-常用知识点/","content":"\n1. let 和 const 命令\n2. 解构赋值\n   ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为**解构**（Destructuring）。\n   解构赋值允许指定**默认值**，只有当一个成员**严格等于undefined**，默认值才会生效。\n   解构赋值在变量声明时不要添加**圆括号**，在变量赋值时可以添加圆括号。\n   ```\n// 错误的写法\nlet x;\n{x} = {x: 1}; // SyntaxError: syntax error\n\n// 正确的写法\nlet x;\n({x} = {x: 1});\n\n   ```\n\n  - 数组的解构赋值\n    只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。（例如：Array 、 Set 、Map 和  Generator 函数）\n  - 对象的解构赋值\n    对象的解构赋值的内部机制，是**先找到同名属性**，然后**再赋值给对应的变量**。真正被赋值的是后者，而不是前者。\n  - 函数参数的解构赋值 \n  - 字符串的解构赋值 \n    `const [a,b] = 'xy' // a='x'; b='y'`\n  - 数值和布尔值的解构赋值\n    只要等号右边的值**不是对象或数组**，就先将其**转为对象**。由于**undefined和null无法转为对象**，所以对它们进行解构赋值，都会报错。\n\n3. 模板字符串 和 标签模板\n","categories":["ES6"]},{"title":"var 、 let 和 const","url":"/2020/12/16/var-let-和-const-的区别/","content":"\n## var 和 let 的区别\n\n1. **作用域不同**。let 有块级作用域。var 只有全局作用域和函数作用域。（例如：for 代码块）js 的作用域只是定义了**变量的可访问性**，但是变量的具体值决定于**代码（函数）执行时机。**\n2. **变量提升和暂时性死区**。 var 存在变量提升。let 不存在变量提升但是有暂时性死区。\n3. **重复声明**。let 不允许在相同作用域内，重复声明同一个变量。var 可以。\n4. **全局对象属性**。 var 声明的变量是全局变量的属性，let 声明的变量却不是。\n\n## 块级作用域\n\nES5 中只存在全局作用域和函数作用域，而 ES6 中添加了块级作用域。块级作用域几个易错点：\n\n- 块级作用域必须要有**大括号**。\n\n```\n// 第一种写法，报错\nif (true) let x = 1;\n\n// 第二种写法，不报错\nif (true) {\n  let x = 1;\n}\n```\n\n- 由于不同浏览器环境对于**函数声明在块级作用域中的行为**差别较大，所以块级作用域中的函数声明最好用**函数表达式来代替**。\n\n## const\n\n**const** 声明一个**只读**的常量。声明变量时，就必须立即**初始化**。\n\nconst 和 let 很多特性类似，包括块级作用域、无变量提升、有暂时性死区、不能重复声明和不绑定全局对象属性。\n\nconst 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。如果真的想将对象冻结，应该使用**Object.freeze**方法。\n","tags":["let","const"],"categories":["ES6"]},{"title":"在线记账项目遇到的问题","url":"/2020/09/24/在线记账项目遇到的问题/","content":"\n1. -webkit-overflow-scroll: touch/auto;可以使移动端浏览器产生过滚动回弹效果，但是下拉body背景会影响fixed布局元素。\n2. 移动端少用100vh,因为100vh包括菜单栏高度和工具栏会导致页面不可控，可以用 css -100% 或者 js document.innerHeight来替代。\n3. flex 布局最后一行左对齐： 给父元素添加after伪元素，设置flex:1\n","categories":["前端"]},{"title":"虚拟 DOM 和 DOM diff","url":"/2020/09/18/虚拟DOM和DOM diff/","content":"\n## 虚拟 DOM\n\n### 虚拟 DOM 是什么\n\n虚拟 dom 的本质就是一个能代表 dom 树的**JS 对象。** 它是相对于浏览器所渲染出来的真实 dom 而言的。它包括标签类型、子元素、属性以及事件等。\n\n在虚拟 DOM 技术出现之前，我们要改变页面内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改 dom 属性或者结构等，来达到更新 ui 的目的。因为每次查询 dom 几乎都需要遍历整颗 dom 树。所以这种方式比较消耗性能。虚拟 dom 对象（ js 对象）以对象嵌套的方式来表示 dom 树，查找 js 对象的属性变化要比查询 dom 树的性能开销小。\n\n### 虚拟 DOM 实例\n\n虚拟 dom 在不同的框架中，有着不一样的具体形式。\n**React 虚拟 DOM** :\n\n```\nconst vNode = {\n  key: null,\n  type:'div',\n  ref: null,\n  props: {\n    children:[\n      {type:'span' ...},\n      {type:'span' ...},\n    ],\n    onClick:()=>{},\n    className: 'main'\n  }\n  ...\n}\n```\n\n**Vue 虚拟 DOM** :\n\n```\nconst vNode = {\n  tag:'div',\n  data: {\n    on:{\n      click:()=>{}\n    },\n    class: 'main'\n  },\n  children:[\n    {tag:'span' ...},\n    {tag:'span' ...},\n  ],\n  ...\n}\n```\n\n### 创建虚拟 DOM\nReact 内置函数：`React.createElement(type,[props],[...children])`\n简化写法： jsx + babel\nVue 内置函数：`h(tag,data,children)`\n简化写法： vue template + vue-loader\n\n### 虚拟 DOM 的优点\n\n1. 减少 dom 操作次数\n   真实 dom 插入 1000 个节点需要进行 1000 次 dom 操作，虚拟 dom 可以将多次操作合并为一次 dom 操作。\n2. 减少 dom 操作范围\n   通过 DOM diff 算法对比新旧虚拟 dom 树,去掉不必要的 dom 操作。例如：添加 1000 个节点，虚拟 dom 通过对比发现有 900 个相同的节点已经存在于相同的层级位置，那么虚拟 dom 只会添加 100 个节点。\n3. 跨平台\n   由于虚拟 dom 本质是 JS 对象，所以它可以变成 DOM、小程序、IOS 应用或者安卓应用。\n\n### 虚拟 DOM 的缺点\n1. 需要额外的创建函数\n2. 需要额外的转义构建工具\n3. 节点数量少时虚拟 dom 效率高，但是节点数量多时虚拟 dom 性能比不上原生dom（vue接近原生dom，react性能偏差）。\n\n## DOM diff \n### DOM diff 是什么\n它的本质是一个函数，类似于`patches = patch(newVDom, oldVDom)`。其中patches就是需要进行的 dom 操作。diff 算法在执行时有三个维度，分别是**tree diff、component diff 和 element diff，**执行时按层级顺序依次执行，它们的差异仅仅因为 diff 粒度不同、执行先后顺序不同。\n\n### DOM diff 的优点\nDOM diff算法会对比 oldNode 与 newNode 的区别，从而**减少不必要的渲染**。\n\n### DOM diff 的问题\nDOM diff在同层级对比中有bug。造成页面渲染错误。**同一层级的一组节点**可以通过唯一的id进行区分, 所以可以给节点设定唯一的key。从而消除bug。**key只能是number和string类型，一定不要用index作为key值。**\n\n### 几个使用key的场景\n1. v-for (vue)\n2. 同一层级有相同标签节点的**transition动画**\n\n","tags":["vDOM","DOM diff"],"categories":["前端"]},{"title":"一篇文章搞懂promise","url":"/2020/08/18/一篇文章搞懂promise/","content":"\n## Promise 解决了什么问题？\n\n在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的**“回调地狱”**。而 `Promise` 将嵌套调用改为**链式调用**，增加了可阅读性和可维护性。也就是说，Promise 用一种更加**友好的代码组织方式**解决了**异步嵌套**问题。Promise的缺陷是无法中断请求。\n产生回调地狱的原因主要有两点：\n\n1. (异步请求)嵌套调用，第一个函数的输出往往是第二个函数的输入；(Promise thenable 链式调用可以解决)\n2. 处理多个异步请求并发，开发时需要同步请求最终的结果。（Promise.all()可以解决）\n\n## then 的链式调用和值穿透\n\n在我们使用 Promise 的时候，当 then 函数中 return 了一个值，不管是什么值，我们都能在下一个 then 中获取到，这就是所谓的 then 的链式调用。而且，当我们不在 then 中放入参数，例：promise.then().then()，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的值的穿透。\n\n## Promise 的 API\n\n- Promise.resolve() 产生一个成功的 promise, 直接将值变成成功结果\n- Promise.reject()  产生一个失败的 promise，直接将值变成错误结果\n- Promise.all()   解决并发问题的，多个异步并发获取最终的结果（如果有一个失败则失败)\n- Promise.race()  处理多个请求,谁先完成用谁的\n- Promise.prototype.catch()   捕获 promise 的异常\n- Promise.prototype.finally()  无论如何都会执行\n\n## Promise/A+ 规范\n\n1. promise 有三个状态：**pending，fulfilled，rejected**, 默认状态是 pending\n2. new promise 时， 需要传递一个 executor(resolve, reject)执行器，**执行器立即执行**\n3. promise 有一个**value 保存成功状态**的值，可以是 undefined/thenable/promise\n4. promise 有一个**reason 保存失败状态**的值\n5. promise **只能**从 pending 到 rejected, 或者从 pending 到 fulfilled，状态一旦确认，就不会再改变\n6. promise 必须有一个 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected\n7. 如果调用 then 时，promise 已经成功，则执行 onFulfilled，参数是 promise 的 value；\n8. 如果调用 then 时，promise 已经失败，那么执行 onRejected, 参数是 promise 的 reason；\n9. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调 onRejected\n10. then 的参数 onFulfilled 和 onRejected 可以缺省，如果 onFulfilled 或者 onRejected 不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；\n11. promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个**“新的 promise\"**\n12. 如果 then 的返回值是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；\n13. 如果 then 的**返回值是一个 promise，那么会等这个 promise 执行完**，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛 1. 出异常，就走下一个 then 的失败\n14. 如果 then 的返回值和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中\n15. 如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略\n\n`Promise实现代码：`\n\n```\nconst PENDING = 'PENDING';\nconst FULFILLED = 'FULFILLED';\nconst REJECTED = 'REJECTED';\n\nconst resolvePromise = (promise2, x, resolve, reject) => {\n  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.\n  if (promise2 === x) {\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n  }\n  // Promise/A+ 2.3.3.3.3 只能调用一次\n  let called;\n  // 后续的条件要严格判断 保证代码能和别的库一起使用\n  if ((typeof x === 'object' && x != null) || typeof x === 'function') {\n    try {\n      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1\n      let then = x.then;\n      if (typeof then === 'function') {\n        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3\n        then.call(x, y => { // 根据 promise 的状态决定是成功还是失败\n          if (called) return;\n          called = true;\n          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1\n          resolvePromise(promise2, y, resolve, reject);\n        }, r => {\n          // 只要失败就失败 Promise/A+ 2.3.3.3.2\n          if (called) return;\n          called = true;\n          reject(r);\n        });\n      } else {\n        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4\n        resolve(x);\n      }\n    } catch (e) {\n      // Promise/A+ 2.3.3.2\n      if (called) return;\n      called = true;\n      reject(e)\n    }\n  } else {\n    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4\n    resolve(x)\n  }\n}\n\nclass Promise {\n  constructor(executor) {\n    this.status = PENDING;\n    this.value = undefined;\n    this.reason = undefined;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks= [];\n\n    let resolve = (value) => {\n      if(this.status ===  PENDING) {\n        this.status = FULFILLED;\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    }\n\n    let reject = (reason) => {\n      if(this.status ===  PENDING) {\n        this.status = REJECTED;\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    }\n\n    try {\n      executor(resolve,reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n<!-- 静态方法 -->\n  static resolve(data){\n    return new Promise((resolve,reject)=>{\n      resolve(data);\n    })\n  }\n\n  static reject(reason){\n    return new Promise((resolve,reject)=>{\n      reject(reason);\n    })\n  }\n\n  static race(promises) {\n    return new Promise((resolve, reject) => {\n      // 一起执行就是for循环\n      for (let i = 0; i < promises.length; i++) {\n        let val = promises[i];\n        if (val && typeof val.then === 'function') {\n          val.then(resolve, reject);\n        } else { // 普通值\n          resolve(val)\n        }\n      }\n    });\n  }\n\n  static all(values) {\n    if (!Array.isArray(values)) {\n      const type = typeof values;\n      return new TypeError(`TypeError: ${type} ${values} is not iterable`)\n    }\n    return new Promise((resolve, reject) => {\n      let resultArr = [];\n      let orderIndex = 0;\n      const processResultByKey = (value, index) => {\n        resultArr[index] = value;\n        if (++orderIndex === values.length) {\n            resolve(resultArr)\n        }\n      }\n      for (let i = 0; i < values.length; i++) {\n        let value = values[i];\n        if (value && typeof value.then === 'function') {\n          value.then((value) => {\n            processResultByKey(value, i);\n          }, reject);\n        } else {\n          processResultByKey(value, i);\n        }\n      }\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    //解决 onFufilled，onRejected 没有传值的问题\n    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;\n    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获\n    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\n    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7\n    let promise2 = new Promise((resolve, reject) => {\n      if (this.status === FULFILLED) {\n        //Promise/A+ 2.2.2\n        //Promise/A+ 2.2.4 --- setTimeout\n        setTimeout(() => {\n          try {\n            //Promise/A+ 2.2.7.1\n            let x = onFulfilled(this.value);\n            // x可能是一个proimise\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            //Promise/A+ 2.2.7.2\n            reject(e)\n          }\n        }, 0);\n      }\n\n      if (this.status === REJECTED) {\n        //Promise/A+ 2.2.3\n        setTimeout(() => {\n          try {\n            let x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e)\n          }\n        }, 0);\n      }\n\n      if (this.status === PENDING) {\n        this.onResolvedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              let x = onFulfilled(this.value);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e)\n            }\n          }, 0);\n        });\n\n        this.onRejectedCallbacks.push(()=> {\n          setTimeout(() => {\n            try {\n              let x = onRejected(this.reason);\n              resolvePromise(promise2, x, resolve, reject)\n            } catch (e) {\n              reject(e)\n            }\n          }, 0);\n        });\n      }\n    });\n\n    return promise2;\n  }\n}\n\nPromise.prototype.catch = function(errCallback){\n  return this.then(null,errCallback)\n}\n\nPromise.prototype.finally = function(callback) {\n  return this.then((value)=>{\n    return Promise.resolve(callback()).then(()=>value)\n  },(reason)=>{\n    return Promise.resolve(callback()).then(()=>{throw reason})\n  })  \n}\n```\n\n## 参考\n[你能手写一个 Promise 吗](https://zhuanlan.zhihu.com/p/183801144)","tags":["promise"],"categories":["js"]},{"title":"防抖和节流","url":"/2020/07/18/防抖和节流/","content":"在前端开发的过程中，我们经常会遇到一些的事件会持续触发，如 resize、scroll、mousemove 等，但有时候我们并不希望事件函数频繁的被执行。这时就需要用到**防抖和节流**\n\n## 防抖（控制次数）\n\n**防抖，就是触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计时。** 常见的实现方法如下：\n```\nfunction debounce (fn,  delay) {\n  let timer = null\n  return function(...args){\n    if(timer){\n      window.clearTimeout(timer)\n    }\n    timer = setTimeout(()=>{\n      fn.apply(this,args)\n    },delay)\n  }\n}\n```\n\n## 节流（控制频率）\n\n**节流，就是事件连续触发时，控制在 n 秒中只执行一次函数，如果在 n 秒内又触发了事件,会忽略触发**。常见的实现方法如下：\n```\nfunction throttle(fn, delay) {\n  let timer = null\n  return function (...arg){\n    if(!timer){\n      fn.apply(this, arg)\n      timer = window.setTimeout(()=>{\n        window.clearTimeout(timer)\n        timer = null\n      })\n    }\n  }\n}\n```\n\n## 防抖和节流的区别\n有时候我们很容易混淆防抖和节流的触发机制，下面我们用一张图来展示他们的区别。\n![防抖和节流的区别](/images/防抖和节流的区别.png)\n\n\n\n\n\n\n","tags":["精华"],"categories":["前端"]},{"title":"vue-cli本地代理mock数据","url":"/2020/05/25/vue-cli本地代理mock数据/","content":"\n近期在做一个项目需要从qq音乐服务器抓取数据，但是由于浏览器同源策略的限制导致获取数据失败，需要从本地nodejs服务器中代理抓取数据，下面是vue-cli中的常见的配置。\n## vue-cli 2.0之前的版本配置\n找到**build/dev-server.js**文件，加入以下代码：\n```\nvar axios = require('axios')\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get('/getSongs', (req, res) => {\n  var url = 'http://www.baidu.com'\n  axios.get(url, {\n    headers: {\n      referer: 'http://www.baidu.com',\n      host: 'http://www.baidu.com'\n    },\n    params: req.query\n  }).then((response) => {\n    res.json(response.data)\n  }).catch((e) => {\n    console.log(e)\n  })\n})\n\napp.use('/api', apiRoutes)\n```\n\n---\n\n## vue-cli 3.0+版本配置\n3.0+版本的vue已将dev-server.js与webpack.dev.conf.js合并，若要写路由相关配置需要找到webpack.dev.conf.js中的**devServer对象**进行相关配置\n```\nconst axios = require(\"axios\")\nconst express = require(\"express\")\nlet app = express()\nlet apiRoutes = express.Router()\napp.use(\"/api\", apiRoutes)\n\ndevServer: {\n        before(app) {\n            app.get(\"/api/getSongs\", function(req, res) {\n                var url = \"http://www.baidu.com\"\n                axios.get(url).then((response) => { res.json(response.data) }) .catch((e) => { console.log(e) }) })\n        },\n    },\n```\n\n---\n\n## vue-cli 4.0+版本配置\n4.0+版本的vue-cli配置藏的更深，需要找到`node_modules/@vue/cli-service/options.js`文件中的**devServer**对象进行配置，配置方法同上面3.0版本类似。另外我们还可以在项目根目录自己新建一个vue.config.js配置文件，新建devServer对象利用**before(app)或者proxy**来进行请求代理。\n```\nconst path = require(\"path\")\nfunction resolve(dir) {\n    return path.join(__dirname, dir)\n}\n\nconst axios = require(\"axios\")\nconst express = require(\"express\")\nlet app = express()\nlet apiRoutes = express.Router()\napp.use(\"/api\", apiRoutes)\n\nmodule.exports = {\n    chainWebpack: (config) => {\n        config.resolve.alias\n            .set(\"@\", resolve(\"src\"))\n            .set(\"assets\", resolve(\"src/assets\"))\n            .set(\"components\", resolve(\"src/components\"))\n            .set(\"base\", resolve(\"baseConfig\"))\n            .set(\"public\", resolve(\"public\"))\n    },\n    devServer: {\n        before(app) {\n            app.get(\"/api/lyric\", function(req, res) {\n                var url = \"http://www.baidu.com\"\n                axios\n                    .get(url)\n                    .then((response) => {\n                        res.json(response.data)\n                    })\n                    .catch((e) => {\n                        console.log(e)\n                    })\n            })\n        },\n        // proxy: {\n        //     \"/api/getLists\": {\n        //         target:\n        //             \"http://www.baidu.com\", //代理接口\n        //         changeOrigin: true,\n        //         pathRewrite: {\n        //          '^/api': ''    //代理的路径 //是否移除api三个字段,\n        //         }\n        //         headers: {\n        //             Referer: \"https://www.baidu.com\",\n        //         },\n        //     },\n        // },\n    },\n}\n\n```\n\n###  nodejs使用res.json()返回响应时，如果直接传入`response`变量会引起循环引用报错,只传入`response.data`就不会出现报错了。\n```\nTypeError: Converting circular structure to JSON\n    --> starting at object with constructor 'ClientRequest'\n    |     property 'socket' -> object with constructor 'Socket'\n    --- property '_httpMessage' closes the circle\n    at JSON.stringify (<anonymous>)\n    at stringify (...\\node_modules\\express\\lib\\response.js:1123:12)\n    at ServerResponse.json (...\\node_modules\\express\\lib\\response.js:260:14)\n    at ...\\vue.config.js:37:41\n    at processTicksAndRejections (internal/process/task_queues.js:97:5)\n```\n","tags":["vue-cli","devServer","proxy"],"categories":["前端"]},{"title":"仿网易云音乐遇到的坑","url":"/2020/05/21/仿网易云音乐遇到的坑/","content":"\n接近一个月没写博客了，这段时间主要在练习一个小项目-[仿网易云音乐](http://caijd.top/163music/src/index.html)。这个项目使用**原生JS和jquery**构建，支持移动端,支持歌单、最新和最热歌曲点播，播放页支持歌词。后台通过leancloud 提供的API搭建。通过这个小项目，我对前后端交互有了更深刻的认识。同时对**MVC和OOP思想**也有了自己的理解。今天我对这段时间学到的新知识和遇到的一些BUG记录下来，以便以后借鉴。\n\n## safari浏览器中的奇怪行为\n1. 在safari中不能**使用js在body中**动态添加`background-image:url()`。否则会出现body背景图片显示不全的BUG。而其他的浏览器目前没有发现这个问题。\n**解决方法：**可以在body中新建一个`div`元素专门用来作为`background-image`的容器\n\n---\n\n2. safari暂时不支持`image/webp`图片格式\n现在很多公司为了优化web性能，网页图片都使用google定义的image/webp图片标准。目前chrome、firefox等主流的浏览器都支持它，但safari和IE由于各种原因暂时不支持image/webp。当我们使用webp图片时就会出现图片不显示的问提。所以我们在使用webp之前需要进行浏览器功能检查。\n\n方法1：尝试加载一张WebP图片，观察是否能够正常加载 \n```\n{\n    let WebP = new Image();\n    WebP.onload = ()=>{     //支持webp       }    \n    WebP.onerror = ()=>{    //不支持webp     }\n    WebP.src = '图片url'\n}\n```\n方法2：通过canvas中特性来判断\n`document.createElement('canvas').toDataURL('image/webp',0.5).indexOf('data:image/webp') === 0`\ncanvas.toDataURL()默认输出**image/png**格式，当支持webp时，上面的表达式输出**image/webp**\n\n---\n\n## 事件中心eventHub和url查询参数\n前端一直在朝着模块化的方向发展，模块的一个功能就是封装方法和属性。那么模块间的数据传递就是摆在我们的眼前的一个难题。模块数据传递目前分为同一页面的数据传递和不同页面的数据传递。\n### 同一页面数据的传递\n如果多个模块在同一个页面，那么我们可以利用**事件中心eventHub**，通过**发布（emit）和订阅（on）**思想来实现数据的传递。\n```\nwindow.eventHub = {\n  events: {},\n  emit(event,data){\n    if(this.events[event] && this.events[event].length){\n      this.events[event].forEach((fn)=>{\n        fn.call(null,data) \n      })\n    }\n  },\n  on(event,fn){\n    if(Array.isArray(event)){\n      event.forEach((item)=>{\n        this.events[item] = this.events[item] || []\n        this.events[item].push(fn)\n      })\n    }else{\n      this.events[event] = this.events[event] || []\n      this.events[event].push(fn)\n    }\n  }\n}\n```\n\n---\n\n### 不同页面间的数据传递\n当多个模块不在同一页面时，eventHub没有了全局的基础，这时候我们可以通过**http请求URL的query参数**(?id=1111&name=cai)来实现数据的传递。或者使用更高级的**cookie ,sessionID以及localStorage**。\n","tags":["js","jquery","leancloud"],"categories":["前端项目"]},{"title":"浏览器同源策略与跨域","url":"/2020/04/19/浏览器同源策略与跨域/","content":"## 同源策略\n只有**协议、域名和端口号完全一致**的两个网站，才可以资源共享。其中受限制的行为包括：\n1. AJAX 请求不能发送。（发送了得不到响应）\n2. Cookie、LocalStorage 和 IndexDB 无法读取。\n3. DOM 无法获得\n\n同源策略的目的，是为了保证用户信息的安全。\n\n---\n## JSONP\n### HTML可以发送请求的元素\n1. form表单和a标签(都会刷新页面,体验不好)\n```\n<form method='get' action='/path' target=''></form>     //将target指向特定的iframe可以间接消除浏览器刷新\n<a href='/path'></a>\n```\n2. img/link元素\n```\nlet img = document.createElement('img')\nimg.src = '/path'\nimg.onload = ()=>{ ...codeBlock }   //必须返回一个图片才会onload\nimg.onerror = ()=>{ ...codeBlock }\n```\n3. script元素\n![server rendered javascript](/images/SRJ.png)\n```\nlet script = document.createElement('script')\nscript.src = '/path'\ndocument.body.appendChild('script') //必须将script加入到dom中，请求才生效\nscript.onload = (e)=>{ ...codeBlock e.currentTarget.remove() }   //先执行服务器返回文本再执行onload回调\nscript.onerror = ()=>{ ...codeBlock }\n```\n---\n### JSONP（json with padding）\n如同上面方法3，JSONP基本思想是,**动态添加一个script元素**，向服务器请求数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n![jsonp小结](/images/jsonp.png)\n---\n#### jsonp注意点\n1. jsonp只能使用get请求\n2. jsonp中script标签src传入的查询参数约定为`?callback=funcName`,其中funcName由字母和**随机数**构成\n3. 服务器通过**回调函数的参数**给浏览器传递任意数据\n---\n## AJAX（async javascript and XML）和 CORS(cross-origi resource sharing)\n早期的前端只能发送简单的get请求。IE 5率先在 JS 中引入**ActiveX**对象，使得 JS 可以直接发起 HTTP 请求（get post put delete）。随后 Mozilla、 Safari、 Opera 也跟进引入了**XMLHttpRequest**对象，最后**XMLHttpRequest**对象被纳入 W3C 规范。\n```\n<!-- 前端代码 -->\nlet xhr = new XMLHttpRequest()\nxhr.open('post','www.baidu.com')        // 打开xhr ，并设置mehtod 和 path\nxhr.setRequestHeader('content-type','text/javascript;charset=utf8') //设置请求头\nxhr.onreadystatechange = (e)=>{\n    if(xhr.readystate === 4){\n        if(xhr.status >=200 && xhr.status <300){\n            console.log('请求成功！')\n            let response = xhr.responseText //获取响应字符串\n            let json = JSON.parse(response) //将字符串转化为js对象\n            ...\n        }\n        else if(xhr.status >=400){\n            console.log('请求失败！')\n        }\n    }\n}\nxhr.send()      //添加参数可以设置request body\n\n\n\n<!-- 后端代码 -->\nif(path === '/path'){\n    response.statusCode = 200\n    response.setHeader('Content-Type','text/json;charset=utf-8')\n    response.setHeader('Access-Control-Allow-Origin','http://www.baidu.com:8080')       //CORS\n    response.setHeader('Access-Control-Allow-Origin','*')   //CORS\n    response.write(\n        `{\n            \"a\": 1,\n            \"b\": 2\n        }\n        `\n    )    \n    response.end()\n}\n```\n\n---\n### AJAX常用的API\n|API| usage|\n|--:--|--:--|\n|xhr.readystate|0-close、1-open、 2-send and receive responseHeader responseStatus、3-download and loading、 4-completed  |\n|xhr.status|状态码 200 400 |\n|xhr.statusText|状态码文本 ok |\n|xhr.responseText|响应 |\n|xhr.getAllResponseHeaders()|获取所有的响应头 |\n|xhr.getAllResponseHeader('')|获取响应头 |\n|xhr.setRequestHeader('')|设置请求头 |\n|JSON.parse('')|string to json |\n|JSON.stringify(obj)|json to string |\n\n---\n### CORS\n由于AJAX存在**同源限制**，所以出现了CORS。CORS就是在服务器端加上响应头。\n```\nresponse.setHeader(\"Access-Control-Allow-Origin\",path)\n```\n\n\n","tags":["浏览器","CORS","JSONP","同源","ajax"],"categories":["前端"]},{"title":"浏览器的http请求过程","url":"/2020/04/19/浏览器的http请求过程/","content":"\n## 浏览器从URL到页面显示的过程\n![浏览器http请求过程](/images/browser.png)\n1. 域名解析，返回IP\n2. 发起TCP的3次握手，建立TCP连接\n3. 浏览器发起http请求，服务器响应htp请求\n4. 浏览器解析html代码,并请求html代码中的资源(如js、css、图片等）\n5. 4次挥手,断开TCP连接\n6. 浏览器对渲染页面呈现给用户\n\n### 域名解析\n域名解析包括**本地DNS缓存查询和远程DNS查询**。\n\n本地缓存查询按照浏览器DNS缓存 → 操作系统DNS缓存 → HOSTS文件的顺序依次查找，如果没有找到对应的IP，再进行远程DNS查询。\n远程DNS查询首先在本地域名服务器（网络接入商提供）缓存上查询，如果没有结果再依次按照根域名服务器 → 顶级域名服务器（.com顶级域名） → 权威域名服务器(二级域名和三级域名)的顺序依次查询，并**将IP依次返回给本地域名服务器、操作系统和浏览器**。\n\n### TCP连接\n#### 三次握手建立连接\n![tcp三次握手](/images/tcp_connect.png)\n\n|FLAGS|meaning|\n|--:------|--:--------|\n|SYN|synchronous 表示请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，一般设置为1|\n|seq|sequence 随机序列码|\n|ACK|Acknowledgement 确认，表示响应|\n|ACKFLAG|确认标志，一般设为1|\n|ACKNumber| 确认号码，表示期待下一次接受的包序号|\n|PSH|push 推送，提示接收端应用程序立即从TCP缓冲区把数据读走|\n|FIN|finish 完成，希望断开连接|\n|RST|reset 复位，对方要求重新建立连接|\n|URG|urgent 紧急指针是否有效。为1，表示某一位需要被优先处理|\n\n\n在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。\n第一次握手：建立连接时，客户端发送**SYN包**(**SYN=1**)到服务器，客户端把这段连接的序号**seq设定为随机数x**,进入**SYN_SEND**状态，等待服务器确认；\n第二次握手：服务器端应当为一个合法的SYN回送一个**SYN/ACK**。ACK的确认码**ACKFLAG=1,ACKNumber=x+1**，SYN/ACK包本身又有一个随机序号**seq=y**此时服务器进入**SYN_RECV**状态；\n第三次握手：最后，客户端再发送一个**ACK**。此时包的序号**seq被设定为x+1**，而ACK确认码则为**ACKFLAG=1,ACKNumber=y+1**。当服务端收到这个ACK的时候，客户端和服务器进入ESTABLISHED状态，完成了三次握手，客户端与服务器开始传送数据。\n\n#### 四次挥手关闭连接\n![tcp四次挥手](/images/tcp_close.png)\n连接终止使用了四次挥手过程（four-way handshake），在这个过程中连接的**每一侧都独立地被终止**。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。\n1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n\n\n## 参考文献：\n[TCP的三次握手与四次挥手理解及面试题](https://blog.csdn.net/qq_38950316/article/details/81087809)\n[传输控制协议 wiki](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)\n\n\n\n\n","tags":["http","浏览器"],"categories":["前端"]},{"title":"认识DOM","url":"/2020/04/11/认识DOM/","content":"<img src='/images/dom.png'>\n\n## DOM\n### MDN解释\n**文档对象模型(DOM)** 将Document(HTML)与脚本（JavaScript）连接起来。但将HTML、SVG 或 XML 文档建模为对象并不是 JavaScript 语言的一部分。**ECMAScript标准和DOM标准是不同机构（W3C和ECMA）维护的不同的标准**。 DOM模型用一个**逻辑树**来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM的方法(methods)让我们可以改变文档的结构、样式或者内容。\n### 理解DOM\n浏览器将Document文档通过构造函数构建成Object对象，形成整个逻辑树，就是DOM。在JS中，所有的对象都继承于**Object**。在DOM中，所有的构造函数都继承于**Node函数**。DOM主要有四大接口：Node，Document，ElementText（还有一些不常见的）。\n\n## Node常见的属性和方法\n### 属性\n```\nchildNodes,firstChild,lastChild,\nnextSibling,previousSibling     //有可能返回文本节点\nnodeName,nodeType,nodeValue,\nouterText,innerText,textContent\nownerDocument,parentElement,parentNode\n```\n### 方法\n```\nappendChild()\ncloneNode()     // true代表深拷贝且false代表浅拷贝（default）\ncontains()\nhasChildNodes()\ninsertBefore()\nisEqualNode()   //内容一致的node时，返回值是true\nisSameNode()    //同一个node时，返回值是true\nremoveChild()\nreplaceChild()\nnormalize() // 常规化\n```\n\n## Document常见的属性和方法\n### 属性\n```\ndocumentElement, body, links, images forms, scripts, title, head,\ncharacterSet,  doctype,  URL, styleSheets,\nchildElementCount, children\nscrollingElement fullscreen hidden location\nonxxxxxx origin plugins readyState \nvisibilityState\nreferrer    //返回跳转到当前页面 的**页面的URI**\ndomain      //document.domain 获取/设置当前文档的原始域部分\n```\n### 方法\n```\nclose()\ncreateDocumentFragment()\ncreateElement()\ncreateTextNode()\nexecCommand()\nexitFullscreen()\ngetElementById()\ngetElementsByClassName()\ngetElementsByName()\ngetElementsByTagName()\ngetSelection()\nhasFocus()\nopen()\nquerySelector()\nquerySelectorAll()\nwrite()\nwriteln()   // 向文档中写入一串文本，并紧跟着一个换行符。\n```\n## Element和Text的API（见MDN）\n\n## 几个需要注意的属性和方法\n1. nextSibling和previousSibling: 有可能返回文本节点\n2. nodeName: 几乎所有的的标签nodeName都是大写，比如‘DIV',但是**docu0ment的nodeName是“#document”，svg的nodeName是svg**\n3. nodeType: element对应1,text对应3\n4. Node.normalize() 方法将当前节点和它的后代节点”规范化“（normalized）。在一个\"规范化\"后的DOM树中，不存在一个空的文本节点，或者两个相邻的文本节点。“空的文本节点”并不包括空白字符(空格，换行等)构成的文本节点。\nps：两个以上相邻文本节点的产生原因包括：\n    1. 通过脚本调用有关的DOM接口进行了文本节点的插入和分割等。\n    2. HTML中超长的文本节点会被浏览器自动分割为多个相邻文本节点。\n5. innerText和textContent的区别\n![innerText和textContent的区别](/images/differenceInText.png)\n6. html、document和documentElement的联系\n![html、document和documentElement](/images/html.png)\n7. document.write()和writeln()\n这两个方法可以在DOM上写入内容。但是要注意document.open()后才可以document.write(),write后执行document.close()。如果此后还需要write内容，那么重新open document会导致DOM内容被覆盖。所以document.write()要**谨慎与定时器**一起使用。\n","tags":["DOM"],"categories":["js"]},{"title":"js函数","url":"/2020/04/06/js函数/","content":"<img src='/images/js_function.png'>\n\n## js函数的5种申明方式：\n函数一定有一个返回值，即使我们申明时没有return,js会自己添加`return undefined`。\n1. 具名函数\n`function add(x,y){return x+y}    //add.name === 'add' `\n2. 具名函数表达式\n`let fn = function add(x,y){return x+y}   //fn.name ==='add' `\n3. 匿名函数表达式\n`let fn = function (x,y){return x+y}    //fn.name === 'fn'`\n4. new Function()\n`let fn = new Function('x','y','return x+y')   //fn.name === 'anonymous'`\n5. ES6箭头函数（只能匿名）\n`let fn = (x,y) => {return x+y}   //fn.name === 'fn'`\n\n方法1和方法2申明的区别：\n1. 方法1`变量add`有申明提升的效果而方法2中`变量add`不会变量提升。\n2. 方法1中`add()`在add函数内部和外部都可以被调用，但方法2中`add()`只能在add函数内部被调用。\n\n## 函数的调用\n1. `fn(param1,param2)`\n4. `obj.fn()`\n2. `fn.call(undefined/null,param1,param2)`\n3. `fn.apply(thisArg, [argsArray])`\n\n## this和arguments\n`函数调用：fn.call(this,arg1,arg2,...)`\n其中，`this`就是第一个参数；`arguments`是除第一个参数外其他参数组成的的伪数组。\n### this\n`this`设计目的就是在函数体内部，指代函数当前的*运行环境*。`this`在**函数调用**时才被确定。它的本质是fn.call(context,arg)传入的第一个参数，一般来说`传入的context`是个对象。非严格模式下，当传入undefined/null时，this指代window全局对象；严格模式下(\"use strict\"),传入undefined/null或者任何数据类型，this值都直接指代传入的值。实现的结果如下：\n1. `fn(param1,param2)` this指向window\n2. `obj.fn()` this指向obj（通过对象方法调用时，this指向最后调用函数的对象）\n3. 箭头函数内部this跟函数外部this一致，箭头函数没有arguments变量\n4. `new fn()`中的this指向被创建的新对象本身\n\n\n## 词法作用域\n作用域就是js**变量的可访问范围**，它决定了变量的可见性和生命周期。函数在**定义时**，就已经决定了它的作用域。作用域分为全局作用域、局部（函数）作用域和块级作用域（let/const)。作用域可以嵌套，嵌套内部作用域可以访问嵌套外部的变量，这样就形成了**作用域链**。\n作用域链是**变量**的可访问范围。\n原型链是**对象属性**的可访问范围。\n### 难点\n作用域在**函数定义时**就已经确定。但是此时确定的只是**变量的可访问范围**，变量的**值并不会确定不变**，所以**函数调用时变量的值由调用时决定**。\n\n## 闭包\n**函数和lexical environment词法环境（包括作用域链）**捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。所以，我们看到有人说一个函数return一个函数就是闭包的说法是错误的，这只是在利用闭包而已。我们**在返回一个函数的同时也返回了这个函数的词法环境（作用域链）**，这样我们就可以在函数外部访问到函数内部的变量了。\n\n## callStack\njs函数调用时会被压入callstack中，标记好，等待函数执行完成(return;)时，会再把函数弹出callstack中。\n","tags":["js","function"],"categories":["js"]},{"title":"js数组","url":"/2020/04/05/js数组/","content":"js 数组就是有序数据的集合。数组的本质是**原型链中有Array.prototype的对象**。Array对象是用于构造数组的全局对象。\n## 申明数组\n1. `let arr = [1,2,3]`\n2. `let arr = new Array(3)   //new可以省略，声明一个length为3的空数组，arr[1] === undefined`\n3. `let arr = new Array(3,3)   //new可以省略，声明一个数组[3,3]`\n\n## 伪数组\n拥有数字key和length属性，但原型链中*没有Array.prototype*的对象称为伪数组。常见的伪数组有：arguments对象、DOM操作中获得的Elements集合。\n\n## 数组常用的API\n1. Array.prototype.forEach()\n` arr.forEach(callback)  //数组的每个元素执行一次callback函数。` \n\n2. Array.prototype.sort()\n```\n//升序排列\nlet numbers = [4, 2, 5, 1, 3]; \nnumbers.sort((a, b) => a - b);          // 在原数组上排序，改变原数组\n```\n\n3. Array.prototype.join()\n` let string = arr.join(',')  //将数组的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符 `\n\n4. Array.prototype.concat()\n` let newArr = arr1.concat(arr2,arr3)  //合并两个或多个数组。不更改现有数组，而是返回一个新数组。 ` \n\n5. Array.prototype.toString()\n`toString()返回一个字符串，表示指定的数组及其元素。`\n\n6. Array.prototype.map()\n返回一个新数组，其结果是原数组中的每个元素都调用callback函数后返回的结果。\n```\nconst array1 = [1, 4, 9, 16];\n// pass a function to map\nconst newMap = array1.map(x => x * 2);\n```\n\n7. Array.prototype.filter()\n`let newArray = array.filter(word => word.length > 6);    //返回一个新数组, 其包含通过所提供函数实现的测试的所有元素` \n\n8. Array.prototype.reduce()\n对数组中的每个元素执行一次reducer函数(升序执行)，并返回最终的ACC结果。\n```\nconst array1 = [1, 2, 3, 4];\nconst reducer = (accumulator, currentValue) => accumulator + currentValue;\nconsole.log(array1.reduce(reducer));     // 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));  // 5 + 1 + 2 + 3 + 4\n``` \n\n9. Array.from(arrayLike)   \n    传入伪数组，返回一个数组\n10. Array.isArray(object)        \n    传入一个对象，判断是否是数组，返回值boolean\n","tags":["js","Array"],"categories":["js"]},{"title":"js全局对象和原型链","url":"/2020/03/29/js全局对象和原型链/","content":"## 全局对象global(浏览器window)\nECMAScript 规定全局对象叫做 global，但是浏览器把 window 作为全局对象。window 的属性就是全局变量。其中的全局变量分为两种：\n1. ECMAScript规定的，例如：\n```\nglobal.parseInt()\nglobal.parseFloat()\nglobal.Number\nglobal.String\nglobal.Boolean\nglobal.Object\n```\n---\n2. 浏览器自己规定的，例如：\n```\nwindow.alert()\nwindow.prompt()\nwindow.comfirm()\nwindow.console.log()\nwindow.console.dir()\nwindow.document\nwindow.document.createElement()\nwindow.document.getElementById()\n```\n---\n### Number\n```\nlet n = 11          //基本number数据类型\nlet n = Number('11');   //显式转化成number类型\nlet n = new Number(11)  //创建number对象，有toString()和valueOf()方法\n11.toString()   //11本身没有toString()方法，当调用toString()时，11会临时转化成Number对象，当toString()调用结束，11会再次变成基本number类型（隐式转换）\n```\n\n### String\n```\nlet n = '22'         //基本string数据类型\nlet n = String('11');   //显式转化成string类型\nlet n = new String(11)  //创建string对象，有toString()和valueOf()方法\n```\n\n### Boolean\n```\nlet n = true         //基本Boolean数据类型\nlet n = Boolean('11');   //显式转化成Boolean类型\nlet n = new Boolean(11)  //创建Boolean对象，有toString()和valueOf()方法\n```\n---\n## __proto__ 和 prototype\n所有的对象都有toString()和valueOf()方法，js将这些公用属性都放在`__proto__`对象中。而为了防止`__proto__`对象因没被引用而被垃圾回收，所以就有了`Object.prototype`。`__proto__`是存在于对象实例中，prototype是存在于构造函数中。\n```\n对象实例.__proto__ === 构造函数.protoType\nlet obj = new Object()   //obj.__proto__ === Object.prototype\n```\n### 对象原型链关系图：\n![js对象与原型链](/images/proto.png)\n\n---\n\n### 几个难懂的原型链\n```\nObject.prototype.__proto__ ==== null\nFunction.__proto__ === Function.prototype\nObject.__proto__ === Function.prototype\n```\n","tags":["js","原型链"],"categories":["js"]},{"title":"js数据类型","url":"/2020/03/28/js数据类型/","content":"## js简史\n1991年，Tim Berners-Lee发明www万维网 \n1992年，Tim Berners-Lee 及其同事发明了css\n1993年， w3c万维网联盟出现\n1995年，Netscape公司推出了navigator浏览器，js之父Brendan Eich用十天时间开发出了js（mocha）。之后，Unicode发布了utf-8\n1996年，Microsoft发布了IE浏览器和JScript\nNetscape开源firefox浏览器，由Mozilla委员会维护。向ECMA(欧洲计算机制造商协会)申报标准并起名ECMAScript.\n2004年 ， Microsoft发布IE5.5，使js可以发送http请求\nGmail的出现，让人们认识到js不仅仅是脚本玩具语言，也可以成为真正的编程语言\n2010年，front-end行业出现\n\nES3 :标准库少  → ES5：IE7不支持 → ES6：IE8不支持\nES6借鉴了rails社区coffeeScript的很多特性：类、箭头函数等，集大家之所长\n后来es每年一更新\n\n## js数据类型\njs有七种数据类型\n基本类型:**number,string,boolean,symbol,null,undefined**\n复杂类型：**object**(包括array,function,date等)\n\n## number\njs中实际上没有整数和小数之分，所有的数字均以**64位浮点**数存储。 它的表示方法如下：\n```\n十进制表示法：0.1  .1   1e-1 \n二进制表示法：0b0101010     #以0b开头\n八进制表示法：0o0101010     #以0开头，ES5新添以0o开头\n十六进制表示法：0x0101010   #以0x开头\n```\n### 类型转换\n1. Number(anything)\n2. parseInt(str)\n3. parseFloat(str)\n4. anything - 0\n5. +(anything)\n\n## string\n### 空字符串：''    （区别于空格字符串'   ')\n### 多行字符串：\n1. 借鉴于bash中语法：\n```\n'aaaa\\\nbbbb'               // 结果为\"aaaa↵bbbb\"   (不推荐使用)\n```\n\n2. ` 'aaaa' + 'bbbb'              // 结果为aaaabbbb   (推荐使用)`\n3. es6新语法：\n```\n`aaaa\nbbbb                // 结果为\"aaaa↵bbbb\"   (推荐使用)\n`\n```\n\n### base64\nBase64就是一种基于64个可打印字符(52个大小写字母、10个数字以及+、/h和=)来表示二进制数据的方法。\n```\nwindow.btoa(str)  //创建一个base64编码的字符串\nwindow.atob(str)  //解码base64编码的字符串\n```\n如果str中包含汉字，上面的方法会报错。这时候需要使用：\n```\nwindow.btoa(encodeURIComponent(str))  //创建包含非ASCII(如汉字)的str的base64\ndecodeURI(window.atob(str))  //解码base64\n```\n\n### 类型转换\n1. String(anything)\n2. toString(anything)\n3. '' + anything\n\n## boolean\nboolean只有true和false。\na && b : 只有两个都为真时，表达式结果为真\na || b ：只有两个都为假时，表达式结果为假\n1. 5个false值：'' ,null,undefined,0,NaN\n2. 所有的对象都是true\n\n### 类型转换\n1. Boolean(anything) \n2. !!anything \n\n## symbol\nSymbol()用来生成一个**全局唯一**的值。\n\n## null和undefined\n它们都表示没有值。\n1. (规范)一个变量没有被赋值，那么这个变量的值就是 undefined\n2. (习惯)如果想表示一个还没赋值的对象，就用 null。如果想表示一个还没赋值的字符串/数字/布尔/symbol，就用 undefined（但是实际上直接 var xxx 一下就行了，不用写 var xxx = undefined）\n\n## object\nobject是基本类型数据无序组合的一种hashTable。\n1. object 的 key 一律是字符串，不存在其他类型的 key\n2. object[''] 是合法的\n3. object['key'] 可以写作 object.key\n4. object的key不加''时，只能是合法的标识符（满足以字母、_、$开头的字符串）或者纯数字，object的key加上''时，可以是任意的unicode字符串\n5. 删除对象key：delete object.key 。删除后object.key==undefined && key in object ==false\n6. 遍历对象key：for(key in object) {code block...}\n7. 获取对象所有的key： Object.keys(obj)\n7. 获取对象所有的value： Object.keys(obj)\n\n## typeof\ntypeof是一个判断变量或者表达式数据类型的**操作符**。使用方法：typeof <variable>或者 typeof(variable)\n```\n    //正常结果\n    typeof 111) === 'number'\n    typeof '111' === 'string'\n    typeof true === 'boolean'\n    typeof Symbol() === 'symbol'\n    typeof undefined === 'undefined'\n    typeof {} === 'object'\n\n    //非常规结果\n    typeof null === 'object'\n    typeof [] === 'object'      \n    typeof function(){} === 'function'    #并没有function类型\n    \n```\n### Object.prototype.toString.call()\n由于typeof存在一些bug，所以准确判断一个变量的类型可以用**Object.prototype.toString.call(<variable>)**。\n```\n    Object.prototype.toString.call(111) === '[object,Number]'\n    Object.prototype.toString.call('111') === '[object,String]'\n    Object.prototype.toString.call(true) === '[object,Boolean]'\n    Object.prototype.toString.call(Symbol()) === '[object,Symbol]'\n    Object.prototype.toString.call(undefined) === '[object,Undefined]'\n    Object.prototype.toString.call({}) === '[object,Object]'\n    Object.prototype.toString.call(null) === '[object,Null]'\n    Object.prototype.toString.call([]) === '[object,Array]'      \n    Object.prototype.toString.call(function(){}) === '[object,Function]'    #并没有function类型\n    \n```\n","tags":["js"],"categories":["js"]},{"title":"算法和数据结构入门","url":"/2020/03/15/算法和数据结构入门/","content":"## 算法\n### 算法的特点\n1. 输入；\n2. 输出；\n3. 明确性；\n4. 有限性；\n5. 有效性（可行性）\n\n### 伪代码和流程图\n1. 伪代码\n伪代码（Pseudocode）是一种非正式的，类似于英语结构的，用于描述算法的语言。使用伪代码使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java等）实现。\n2. 流程图\n流程图是使用图形表示算法的一种方式。其中圆角矩形表示开始和结束，矩形表示正常的运算，棱形表示判断语句，箭头表示运算顺序。\n\n### 常见的算法思想\n1. 分治法（前端最常用的算法思想）\n2. 动态规划法\n3. 贪婪法\n4. 线性规划法\n5. 精并法\n\n### 常用的排序算法\n1. 冒泡排序-两两比较，视情况而定交换位置。时间复杂度为O(n^2)\n2. 选择排序-依次选择最大或者最小的放在最前面\n3. 插入排序-每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。类似于‘起扑克牌’\n5. 快速排序法-通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序\n4. 计数排序法-借助hash表的特殊的桶排序，空间换换时间。复杂度Ο(n+k)‘类似于玩空当接龙’\n6. 基数排序\n在[visualgo.net](https://visualgo.net)上能可视化排序算法的实现过程。\n\n## 数据结构\n### 数据结构\n数据结构(data structure)是**带有结构特性的数据元素的集合**。数据结构是计算机存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关，**算法离不开数据结构**，在规划算法前，要先想好**数据结构**。js中简单的数据结构包括**数组和对象。**\n\n### 常见的几种数据结构\n1. hash（哈希表）\n散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。在js中，一个对象就可以称为一个hash table。\n在桶排序和计数排序中就用到了hash表。\n\n2. queue（队列）\nqueue是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为**队尾**，进行删除操作的端称为**队头**。队列中没有元素时，称为**空队列**。\n特点：\n    1. 先进先出\n    2. js中可以用数组实现（push，shift）\n    3. 类似于‘排队，先排队的在前面就会先出去，前面的地方就是**队头**，后面的地方就是**队尾**’\n\n3. stack（栈）\nstack在计算机科学中是限定仅在**表尾**进行插入或删除操作的线性表。进行删除和插入的一端称**栈顶**，另一端称**栈底**。插入一般称为**进栈**，删除则称为**退栈**。 栈也称为**后进先出表**。\n特点：\n    1. 后进先出\n    2. js中可以用数组实现（push，pop）\n    3. 类似于‘往桶里放东西，后放进去的在上面就会被先拿出来，桶的的上方就是**栈顶**，底部就是**栈底**’\n\n4. 链表\n链表是一种非连续、非顺序的数据结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成。**每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。**\n    1. 线性表的缺点就是**删除元素麻烦**，链表是非线性表它的缺点是**查询元素麻烦**。\n    2. 链表一般包括head和node\n\n5. 树\n树是一种数据结构，它是由n（n>=0）个有限结点组成一个具有层级结构的集合。每个结点有零个或多个子结点；没有父结点的结点称为**根结点**，没有子结点的结点称为**叶子结点**。**结点的层次**：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。一棵树中所有结点的层次的最大值称为这棵树的**深度**。\n    1. 二叉树：每个节点最多含有两个子树的树称为二叉树；\n    2. 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。\n    3. 完全二叉树：完全二叉树是由满二叉树而引出来的。满二叉树最后一层的最后的结点**连续的**丢失掉形成的树。\n    4. 满二叉树和完全二叉树可以用js数组实现，其他的树需要用链表实现。\n\n6. 堆（heap）\n堆是特殊的完全二叉树。堆中**某个节点的值总是不大于或不小于其父节点的值**。当根节点的值是最大的值时，这样的堆称为**最大堆**。当根节点的值最小时，称为**最小堆**。\n**堆排序**就是兄弟节点和父节点比较取最大值作为新的父节点，不断的构成最大堆或者最小堆，由此达到排序目的的算法。","tags":["算法","数据结构"],"categories":["算法"]},{"title":"HTML入门","url":"/2020/03/13/HTML入门/","content":"HTML全称**Hypertext markup language**，它是整个网页的内容（骨架）。学习HTML就是要掌握好它常用的标签，html标签在网页中又叫html元素。它分为block元素，inline元素和inline-block元素。这些都只是标签默认的属性，实际开发中都可以通过css改变。\n\n## HTML版本\nHTML版本主要有：HTML 4.01 → XHTML → HTML 5 → HTML 5.1，由W3C根据浏览器实际情况编写文档。`<!DOCTYPE HTML>`用来声明文档类型。\n\n## HTMl标签\n### 常见的html标签\n`(html、body、head）、a、form、input、button、h1(h2、h3 )、p、ul、ol、small、strong、div、span、kbd、video、audio、svg。\n`这些标签除了div和span，其他标签都有默认样式。\n### 空标签\n空标签里面不能有内容（子元素），通常在一个空元素上不需要使用闭合标签。例如：\n```\n<br /> 换行标签，通常用于文本格式换行\n<hr/> 水平分割线\n<input />  用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。\n<link /> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件。\n<img /> 文档中的图像。\n<meta /> 元素表示那些不能由其它HTML元相关元素 (<base>, <link>, <script>, <style> 或 <title>) 之一表示的任何元数据信息. \n\n<isindex /> 使浏览器显示一个对话框，提示用户输入单行文本。\n<area /> 在图片上定义一个热点区域\n<param />  定义了 <object>的参数\n<col /> 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于`<colgroup>`元素内。\n<bgsound /> IE浏览器中设置网页背景音乐的元素。\n<wbr /> 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。\n<base /> 指定用于一个文档中包含的所有相对URL的基本URL。\n<nextid />  是一个过时的 HTML 元素, 它使下一个 web 设计工具能够为其定位点生成自动名称标签。 它是由该 web 编辑工具自动生成的, 不需要手动调整或输入。这个元素的区别是成为第一个元素, 成为一个 \"丢失的标签\" 被淘汰的官方公共 DTD 的 HTML 版本。\n<basefont /> 用来设置文档的默认字体大小。（目前已废弃 ）\n<embed /> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。 \n<keygen />  为了方便生成密钥材料和提交作为 [HTML form]的一部分的公钥.这种机制被用于设计基于 Web 的证书管理系统。(已废弃)\n<plaintext /> 将起始标签后面的任何东西渲染为纯文本，不会解释为 HTML。它没有闭合标签，因为任何后面的东西都会看做纯文本。(已废弃)\n<spacer /> 它可以向页面插入间隔。它由 Netscape 设计，用于实现单像素布局图像的相同效果，Web 设计师用它来向页面添加空白，而不需要实际使用图片。（已废弃）\n ```\n### 可替换元素\n可替换元素（replaced element）的内容不受当前文档的样式的影响，CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。例如：`<img> <iframe> <video> <embed> `,某些元素仅在特定的情况下是可替换元素，例如：`<option> <audio> <canvas> <object> <applet> <input>`.用 CSS `content` 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的”。\n\n### 几个重点标签\n#### iframe和a标签\n```\n<iframe src='https://qq.com' name='page1' frameborder='0'>   //嵌套页面 页面默认大小是100*50px\n<a href='#' target='_self'>Hello</a>  //跳转标签（get请求）\n```\n1. a标签的target取值：`_self(defaults) _blank  _parent _top framename`\n其中_parent和_top是结合iframe嵌套父子关系来确定的。通过指定target='framename'可以使页面在对应的iframe中显示。\n\n2. 通过a标签下载文件\n    1. 通过指定a标签的download属性可以强制文件下载。\n    2. 如果不加download，而且http响应的内容浏览器不能展示那么文件也会被下载，例如：content-type:application/octet-stream.\n\n3. a标签herf=''的取值：(最好不要用file协议（file:///)来打开文件。)\n    1. ` http(s)://XXX `    http/https协议地址。    （例如 http://qq.com) 浏览器会向服务器发送get请求\n    2. `//XXX`        继承当前文件协议。 （例如 //qq.com) 浏览器会向服务器发送get请求\n    3. `XXX `          相对路径。 （例如 qq.com) ，浏览器会向服务器发送get请求\n    4. `#XXX`     锚点。跳转到当前页面指定的id处，且锚点会添加到url后面，但是浏览器不会向服务器发送请求\n    5. `?name=cai`  浏览器会向服务器发送get请求 ,查询字符串会添加到url后面\n    6. `javascipt:;` javascript伪协议。\n\n#### form和input标签\nform和a标签都可以发起请求。a只能发起get请求，form既可以发get,也可以发post请求。不过form一般用来发post请求，提交表单内容。它们target属性的功能也是一样的。\n```\n<form action='index.php' method='post' target=''>\n    <input type='password' name='XXX' value=''> \n    <input type='checkbox' name='XXX' value=''> \n    <input type='radio' name='XXX' value=''> \n    <select name='hobby' multiple>\n        <option value='basketball'>basketball</opiton>\n        <option value='baseball' disabled>baseball</opiton>\n        <option value='soccer'>soccer</opiton>\n    </select>\n    <textarea style='resize:none' name='info'></textarea>  \n    <input type='submit' name='XXX' value=''> \n    <button>button</button>     当表单中没有提交按钮，那么未设置type的button按钮会自动升级为submit按钮\n</form>\n```\n1. form中的input**必须添加name和value属性**，它们在提交的时候会以键值对的形式发送给服务器。这时候name和id意义不同。\n3. input[type='checkbox']和input[type='radio']可以通过name属性给选项分组，radio默认value是'on'.\n2. label指定标签的两种用法：\n    1. 指定for\n        `<label for='check'>性别</label><input id='check' type='checkbox' name='sex' value='man'>man`\n    2. label包裹input\n    `<label>性别<input id='check' type='checkbox' name='sex' value='man'>man</label>`\n4. textarea 默认是可变尺寸的。通过css `resize:none`可以取消默认样式。宽度和高度也最好用css来设置，rows和cols属性不可靠，尤其是cols。\n5. input[type=button]和button标签的区别：input是空标签，button不是；而且**未设置type的button可以自动升级为submit**。\n\n\n#### table标签\n```\n\t<table border=\"1\">\n\t\t<colgroup>\n\t\t\t<col bgcolor='red' width='100'>\n\t\t\t<col bgcolor='red' width='100'>\n\t\t\t<col bgcolor='red' width='100'>\n\t\t\t<col bgcolor='red' width='100'>\n\t\t\t<col bgcolor='red' width='100'>\n\t\t</colgroup>\n\t\t<thead>\n\t\t\t<tr><th></th><th>姓名</th><th>班级</th><th>语文</th><th>数学</th></tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr><th></th><td>小明</td><td>1</td><td>50</td><td>60</td></tr>\n\t\t\t<tr><th></th><td>小红</td><td>2</td><td>58</td><td>49</td></tr>\n\t\t\t<tr><th></th><td>小明</td><td>1</td><td>50</td><td>60</td></tr>\n\t\t\t<tr><th></th><td>小红</td><td>2</td><td>58</td><td>49</td></tr>\n\t\t</tbody>\n\t\t<tfoot>\n\t\t\t<tr><th>平均分</th><td></td><td></td><td>50</td><td>80</td></tr>\n\t\t</tfoot>\n\t</table>    \n```\n1. 以上是table的完整结构，其中colgroup、thead、tbody和tfoot的顺序可以打乱，浏览器会自动调整好顺序thead→tbody→ tfoot。\n2. 如果不加thead、tbody和tfoot这些标签，那么浏览器会自动把内容放入tbody中。\n3. colgroup可以设置table的部分样式。css中`border-collapse:collapse`可以设置table的border样式。","tags":["html"],"categories":["html"]},{"title":"http入门","url":"/2020/03/07/http入门/","content":"\n在之前的一段时间的里我着重去学习了 html,css,js 以及 vue 等应用类知识点，而忽略了 http 的学习，导致遇到问题有些力不从心，无法洞悉问题的本质，所以这几天重新学习了一下 http。\n\n## www（world wide web）\n\nhttp 出现之前，人们主要通过 email 和 ftp 的方式来上网交流。1980-1990 年间，http 和 gopher 等方案被提出，后来 http 以其易用性胜出。1990 年，Tim Berners-Lee（李爵士）发明了 www，主要包括三个概念：**URI,HTTP 和 HTML**\n\n## URL\n\nURI（uniform resource identity）通用资源标识符包括 URN（uniform resource name)和 URL(uniform resource location)。\n通过 URN 可以确定唯一的资源，URL 可以确定唯一的地址。\n\n### URL 的组成\n\nURL 通常由协议、主机、端口、路径、查询参数以及锚点等组成。\n![url结构](/images/url.png)\n`protocol :// hostname[:port] / path / [parameters][?query]#fragment`\n**协议**：http，https，[ftp，mailto，ed2k，file:///]\n**主机**： `.com 一级域名（顶级域名） baidu.com 二级域名 www.baidu.com 三级域名\n**端口**：对应服务器端口。每个端口的分配功能不同。（默认端口 80）\n\n| 端口 | 分配功能  |\n| :--: | :-------: |\n|  21  |    ftp    |\n|  53  |    DNS    |\n|  80  | **http**  |\n| 443  | **https** |\n| 1080 | 代理端口  |\n\n**路径**：以‘/’开头的路径，不同于文件系统的路径，它决定于后端的路由。\n**查询参数**：请求或查询的键值对\n**锚点**：这个部分不会发送给后端，它根据前端页面元素 id 值来跳转。\n\n### DNS（domain name system)域名系统\n\n我们访问网页，最终都是在访问域名对应**IP 地址**的服务器。浏览器中的域名会先在电脑中的**HOST 文件**(vi /etc/hosts)中寻找对应的 IP，如果找不到就会去电信公司的 DNS 系统中寻找。很多大公司会有多台服务器，这样同一个域名可能对应多个 IP，DNS 系统会根据就近原则返回给我们对应的服务器。\n查询 ip：\n\n```\nnslookup <域名>\nping <域名>\n```\n\n## http\n\n互联网中包含客户端和服务器。我们在浏览器中上网实际上是：client 发送请求 →server 接受请求 →server 发送响应 →client 接收并下载响应。\n**bash 访问 url:** `curl [-X <get/post/put/patch/delete>] [-d \"12345\"] -s -v [-H \"a:b\"] -- <url> `\n\n### http 请求格式\n\n```\n    part1 动词 路径 协议/版本\n    part2 Key1: value1\n    part2 Key2: value2\n    part2 Key3: value3\n    part2 Content-Type: application/x-www-form-urlencoded\n    part2 Host: www.baidu.com\n    part2 User-Agent: curl/7.54.0\n    part3\n    part4 要上传的数据\n```\n\n1. 请求最多包含四部分，最少包含三部分。（第四部分可以为空）\n2. 第一部分请求动词包括 GET（获取/查询） POST(上传) PUT(整体更新) PATCH(局部更新) DELETE(删除) HEAD OPTIONS 等\n3. 第一部分的路径包括「查询参数」，但不包括「锚点」（注意区别于 url 路径）。如果你没有写路径，那么路径默认为 ‘/’\n4. 第二部分中的 Content-Type 标注了第 4 部分的格式，第二部分都是 key-values。\n5. 第三部分永远都是一个回车（\\n）。\n6. 第四部分是要上传的数据，可以为空。如果上传的数据是汉字，那它会被解析为以“%”分隔的三字节的 unicode。\n\n![http请求示例](/images/request.png)\n\n### http 响应格式\n\n```\npart1 协议/版本号 状态码 状态解释\npart2 Key1: value1\npart2 Key2: value2\npart2 Content-Length: 17931\npart2 Content-Type: text/html\npart3\npart4 要下载的内容\n```\n\n1. 第一部分的状态码是服务器对浏览器说的话。\n   1xx 不常用\n   2xx 表示请求成功 （200 成功 204 创建成功）\n   3xx（301 网页永久移走 302 网页暂时移走 304 响应内容与上次一样）\n   4xx 表示客户端请求出错,一般是 404\n   5xx 表示服务器出错\n2. 第二部分中的 Content-Type 标注了第 4 部分的格式，Content-Type 遵循 MIME 规范。\n3. 第三部分永远都是一个回车（\\n）。\n4. 第四部分是要下载的数据。\n   ![http响应示例](/images/response.png)\n","tags":["http"],"categories":["前端"]},{"title":"git和github的使用","url":"/2020/03/05/git和github的使用/","content":"\ngit是一个代码版本管理工具，git可以创建本地和远程仓库，其中github就可以作为远程代码仓库。windows中要使用git需要安装git bash。\n### git bash\ngit bash是一套linux虚拟环境，内置linux命令和git命令。它是比cmd更好用的命令行工具。\n安装完成后首先全局设置好用户名，用户邮箱等属性。\n```\nnpm config set registry https://registry.npm.taobao.org\ngit config --global user.name xxx #设置username\ngit config --global user.email xxx #设置邮箱\ngit config --global push.default simple # \ngit config --global core.quotepath false #防止文件名变成数字\ngit config --global core.editor \"vim\" # 使用vim编辑提交信息\n```\n### 本地仓库\n1. 初始化仓库 git init\n```\ncd <path>\nmkdir <dirName>\ncd <dirName>\ngit init    #初始化仓库\n```\n\n2. git add [-A /-u/./<path>] \n添加文件或者文件夹到本地仓库暂存区（有些地方也称为索引库）。\n```\n    git add <path>  添加指定的文件和文件夹\n    git add .       添加仓库中所有变动到暂存区，但**不包括删除的文件**\n    git add -u      添加已经tracked的文件变动至暂存区，但不包括**新添加的文件**\n    git add -A      添加所有文件和变动至暂存区\n```\n\n3. git commit [<-m description>]\n将暂存区的内容提交到本地仓库。如果不添加-m参数，那么会自动打开vim编辑器让我们输入commit描述。\nvim编辑器通过<kbd>i</kbd>来切换编辑模式，编辑完成后通过<kbd>esc</kbd>来切换命令模式，并使用<kbd>:wq</kbd>保存退出或者使用<kbd>:q!</kbd>不保存直接退出。\n\n### 远程仓库\n1. 远程仓库创建：直接在github上create repository\n2. 关联远程仓库\n```\n    git remote add origin git@github.com:XXX/YY.git     # ssh关联\n    git remote add origin https://github.com/XXX/YY.git     # https关联\n```\n\n3. 推送到远程仓库\n```\n    git pull    #当远程库被人为改变导致本地和远程仓库不一致，就需要git pull后再git push\n    git push -u origin master \n```\n\n### 其他常用指令\ngit status <-sb> 查看git状态(显示总结和分支)\ngit log 查看提交记录\ngit clone <地址>  克隆代码\ngit remote set-url origin git@github.com:xxxxx.git 重新设置远程地址\ngit branch 新建分支\ngit merge 合并分支\ngit stash 保存当前进度但不提交，然后可以切换到其他分支\ngit checkout 切换分支\ngit stash pop 读取之前保存的未提交记录\ngit revert 撤销某次提交\ngit reset 回退到撤销点\ngit diff 查看详细变化\n\n### 几个文件的作用\n.gitignore 忽略提交的文件或者文件夹\nREADME.md  文档的描述\nLISENCE 开源协议许可证\n\n### 新的github账号\n首次创建github账号或者需要github支持多台设备时，就需要用到SSH绑定。\n#### SSH key的获取\nwindows系统中, 通常\"\\~/\"代表绝对路径\"/c/Users/Administrator\"（或者说当前用户user的绝对位置）。在\"~/.ssh/\" 中有两个文件，id_rsa相当于钥匙，id_rsa.pub相当于锁。我们只需要复制id_rsa.pub到github的SSH key中即可。\n可以通过以下命令来获取新的SSH key：\n```\n rm -rf ~/.ssh/*    #删除原来的key\n ssh-keygen -t rsa -b 4096 -C \"你的邮箱\"    # 连按三次enter，生成新的key\n```\n与github绑定后，通过```ssh -T git@github.com```来验证是否绑定成功。","tags":["git","github"],"categories":["前端"]},{"title":"工欲善其事必先利其器","url":"/2020/03/02/工欲善其事必先利其器/","content":"今天把在前端开发中常用到的工具汇总一下，并附上下载和使用说明地址以供日后查阅。\n\n|软件名称|用途|下载地址|\n|:-----:|:--:|:-----:|\n|ld|fq(愉快的上网)|[地址](https://getlantern.org/zh_CN/index.html)|\n|colorpix|取色器|[地址](https://colorpix.en.softonic.com/)|\n|VSCode|代码编辑器|[地址](https://code.visualstudio.com/)|\n|sublime3|代码编辑器|[地址](https://www.sublimetext.com/)|\n|Node.js/npm|node环境|[地址](https://nodejs.org/en/)|\n|git|代码管理工具|[地址](https://git-scm.com/downloads)|\n\n上面这些软件都打包到百度云备份。\n## ld\nld免费版有流量限制，[破j方法在此](https://github.com/YoulianBoshi/lantern-vpn)，破j后可以无视流量。也可手动更改mac地址，win7 mac地址第二位必须是2,6,A,E中的一个，一般以2A开头才有效（切记备份初始mac）。\n\n## node.js\nnode.js安装完成后，在CMD或者Git Bash中使用。\nnode.js安装后自带npm。npm是包管理工具，常见用法可见[自己总结的文章](/2019/10/30/npm常用的命令)。\n### 配置\nnpm 的配置被存储在 ~/.npmrc。打开 Git Bash，依次输入以下命令，按回车：\n```\nnpm config set registry https://registry.npm.taobao.org/\nnpm config set loglevel http\nnpm config set progress false\n\n```\n### 使用\n进入：在git bash中输入node，回车，就可以进入 node 运行环境，此时就可以写 JS 了。\n退出：ctrl+D 退出           ctrl+C 中断\n\n## Git\ngit bash是一套linux虚拟环境，内置linux命令和git命令。它是比cmd更好用的命令行工具。\ngit bash安装后也需要配置：\n```\ngit config --global user.name xxx #设置username\ngit config --global user.email xxx #设置邮箱\ngit config --global push.default simple # \ngit config --global core.quotepath false #防止文件名变成数字\ngit config --global core.editor \"vim\" # 使用vim编辑提交信息\n```\n### git小白专用命令：\n```\ngit init\ngit add\ngit commit\ngit pull\ngit push (origin master)\ngit clone\ngit status [-sb]\n```\n关于git的使用方法请移步：[廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n## git bash命令行\n以'/'开头的路径就是绝对路径，它是文件的完整路径。\n不以'/'开头的路径就是相对路径。\n### 常用命令\n1. cd ~/desktop   #改变文件夹\n2. mkdir [directory] #添加文件夹\n3. touch [filename]/ echo [content] > [filename] #添加文件\n4. vi [filename] 使用vim编辑文件\n5. open/start [filename] 打开/执行文件\n6. mv [filename1] [filename2] 移动或重命名文件\n7. cp [filename1] [path] 复制文件\n8. rm [-rf] [filename] 删除文件或者文件夹\n9. ls -l  显示文件详细信息\n10. chmod +x [filename] 使文件可执行\n\n### ~/.bashrc文件\n1. git bash 启动时会优先自动.bashrc文件中命令，所以可以自定义一些自启动命令。\n2. bashrc文件中可以起别名：\n``` \nalias la='ls -a'\n```\n\n3. 可以设置一些环境变量和系统PATH值\n在bash中，可执行的文件就是命令，如sh，cp，mkdir,mv等，不可执行的文件就是配置。\n1. 可以直接使用[demo.sh]来执行命令，此时必须将demo.sh的pwd添加到$PATH中。\n2. 使用[sh demo.sh]执行命令，bash会在当前目录中查找文件，未查到目标就在$PATH中查找。\n\n```\nexport SASS_BINARY_SITE=\"https://npm.taobao.org/mirrors/node-sass\"\nexport PATH=\"目录的绝对路径:$PATH\"  # 添加绝对路径到系统PATH中\n```\n2个好用的命令行网站：\n1. [explainshell](https://explainshell.com/)\n2. [tldr](https://github.com/tldr-pages/tldr)\n","tags":["软件下载"],"categories":["前端"]},{"title":"v-if和v-show","url":"/2020/02/27/v-if和v-show/","content":"\n## v-if和v-show的区别\n1. v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加display:none，dom元素还在。\n2. 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗。\n3. 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留。\n\n## display:none和visiblity:hidden的区别\n1. display:none 不占页面空间，元素不占页面空间后，该元素和其内部元素的宽高值永远是0。visiblity:hidden占据原先页面空间。如果想隐藏又想取到宽高值，那就得用visiblity:hidden。\n2. display:none 的子元素也一定无法显示，visiblity:hidden的子元素可以设置显示。display:none元素及其子元素都将隐藏，而visiblity:hidden元素的子元素却可以设置visibility: visible 显示出来。在这一点上，如果页面是比较复杂或者是不受控制的，就要慎重使用visiblity:hidden，因为保不齐哪个元素被设置成可见，影响显示效果。\n3. display:none 引起页面重绘和回流， visiblity:hidden只引起页面重绘。visiblity:hidden看起来的性能比display:none好些在两者都能使用情况下，可先考虑visiblity:hidden。","tags":["v-if","v-show"],"categories":["css"]},{"title":"position定位小结","url":"/2020/02/23/position定位小结/","content":"\n## position属性\nposition属性的值有static(默认值)，relative，absolute，fixed。\n\n### static:\n所有元素默认值。即没有定位，元素仍出现在正常文本流中。\n特性：\n1. ***忽略 top, bottom, left, right或者z-index声明***。\n\n### relative:\n相对定位元素会**相对于它自己在正常流中的默认位置**偏移。\n特性：\n1. 相对于自己偏移，但原来所占的位置将继续占有，没有脱离标准文档流，**可设置z-index属性**。\n2. 每次移动是以自己的左上角为基点移动。\n\n### absolute: \n生成绝对定位的元素。**相对于static定位以外**的第一个父元素进行定位。脱离正常文档流，**可设置z-index属性**实现层叠。\n特性：\n1. 绝对定位偏移基准点是父元素的**padding-box左上角**，即absolute元素的margin-box相对于父元素的padding-box偏移。\n2. 没有设置定位值(left,right,top,bottom)的元素，仍处在原本在标准流中的位置。但是它已经脱离了文本流，不会影响兄弟元素的布局。\n3. 绝对定位元素的宽高百分比是相对于其最近的父级别定位元素的padding-box的大小来计算的。\n4. 定位值（left,right,top,bottom）的百分比也是相对于父元素的padding-box宽高来计算的。\n5. 当left，right，top，bottom无法同时满足时，优先满足left和top。\n\n### fixed:    \n固定定位。一般**相对于浏览器窗口**进行定位，脱离正常文档流，可以设置z-index。\n特性：\n1. 固定定位相邻父元素出现transform和perspective属性，那么此时固定元素相对于父元素定位而不是浏览器窗口。\n2. fixed固定定位对于IE6,7,8不兼容。\n3. fixed固定定位元素的宽高百分比是相对于浏览器窗口（body的border-box）来计算的。\n4. 固定定位偏移基准点是视口的左上角，即fixed元素的margin-box相对于body的border-box偏移。\n\n任何元素都可以定位。不过***绝对或固定定位会生成一个BFC***。\n\n## 小结：\n1. 触发 BFC\nBFC可看成XY方向上标准流布局图层，只要元素满足下面任一条件即可触发 BFC 特性：\n    1. body 根元素\n    2. 浮动元素：float 除 none 以外的值\n    3. 绝对定位元素：position: (absolute、fixed)\n    4. display 为 inline-block、table-cells、flex\n    5. overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n2. z-index（默认值auto）\n    1. 只有position为relative/absolute/fixed时（除了static）,Z-index才生效。\n    2. z-index:0和z-index:auto层叠水平一样。但是z-index:auto不会产生层叠上下文，而z-index:0(或者数值)都会产生新的层叠上下文。\n    3. 同一层叠上下文，z-index越大层叠水平越高，层叠水平相同后来居上。\n    4. 不同层叠上下文比较，要比较其父元素层叠水平。\n\n3. 层叠顺序和层叠上下文\n    1. 七层层叠顺序\n    ![七层层叠顺序](/images/123.png)\n    2. 层叠上下文\n    层叠上下文可看成Z方向上布局图层。元素满足下面任一条件即可产生新的层叠上下文：\n        1. html根元素 。\n        1. position值为 absolute|relative，且 z-index值不为 auto。\n        1. position 值为 fixed|sticky。\n        1. z-index 值不为 auto 的flex元素，即：父元素 display:flex|inline-flex。\n        1. opacity 属性值小于 1 的元素。\n        1. transform 属性值不为 none的元素。\n        1. mix-blend-mode 属性值不为 normal 的元素。\n        1. filter、 perspective、 clip-path、 mask、 mask-image、 mask-border、 motion-path值不为none的元素 。\n        1. perspective 值不为 none 的元素。\n        1. isolation 属性被设置为 isolate 的元素 。\n        1. will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值。\n        1. -webkit-overflow-scrolling 属性被设置 touch的元素。\n。\n","tags":["position","z-index","absolute","BFC","层叠上下文"],"categories":["css"]},{"title":"inline、inline-block和block元素的区别","url":"/2020/02/23/inline和inline-block的区别/","content":"常见的元素有block块元素,inline内联元素和inline-block元素。\n## block元素特点\n1. 宽度默认auto,**block元素width:auto时，宽度会尽可能宽。**（默认填满父元素）,单个block元素独占一行，**即使宽度设为0px**。\n2. 宽度和高度可以设置。\n3. padding、margin、border都可以设置。\n4. 内部可以嵌套block、inline和inline-block等各种元素。\n\n## inline元素的特点\n1. 不会独占一行，多个inline元素可以占据同一行，直到宽度超过父元素才会另一行。\n2. 宽度和高度不可以设置，默认为auto，由内容宽高决定，具有包裹性。\n3. **padding、margin和border在水平方向上可以设置，垂直方向上（padding-top|padding-bottom|margin-top |margin-bottom|border-top|border-bottom）设置无效**。border-top和border-bottom即使在视觉上有效果，但实际上布局上不起作用。 \n4. inline元素内部理论上不可以嵌套block元素\n\n{% iframe /pages/demo4 100% 400px %}\n\n## inline-block元素特点\ninline-block同时具备inline和block元素的特点。\n1. 不独占一行\n2. 宽高可以设置，当宽高设为auto时又具备包裹性\n3. padding、margin、border都可以设置\n4. 内部理论上不可以嵌套block元素\n\n## 小结 \n1. inline和inline-block元素**第三条**特点的差别很容易让人忽略。\n2. inline元素由于内容而自动换行后，会导致border破裂。\n"},{"title":"width百分比小结","url":"/2020/02/22/width百分比小结/","content":"\nwidth:100%中百分比肯定是相对于父元素而言的，但是由于padding，box-sizing等属性的影响，有时候会迷惑我们。所以今天对这个问题总结一下。\n## box-sizing\nbox-sixing属性主要有content-box和border-box两个值，默认是content-box。这个属性直接影响元素本身的width值，间接影响子元素width值。\n{% codeblock lang:css %}\n    box-sizing: content-box    //当前元素width值只包括content宽度\n    box-sizing: border-box    //当前元素width值包括content,padding以及border的值\n{% endcodeblock %}\n\n## width:100%的元素是绝对定位\n1. absolute绝对定位元素的父元素是非static定位元素。它的width:100%取值等于父元素的content值加上padding值(与border-width无关)。\n2. fixed固定定位元素的父元素是body（即浏览器窗口）。它是特殊的绝对定位，fixed固定定位元素的width:100%取值等于父元素（body）的content值和padding值以及border值之和。(与border-width有关)。\n总的来说，**fixed固定定位元素的width:100%等于浏览器窗口的width。**\n\n## width:100%的元素是非绝对定位\n非绝对定位元素width:100%的取值等于父元素的content值。包括position:relative相对定位元素也符合这一规则。\n\n**浏览器url中出现“：”容易报错，所以width：100%不允许出现在标题中。**\n\n## 小结\nwidth百分比的计算要注意两点：\n1. 找准父元素。\n    1. 普通文本流和relative相对定位元素以及static定位元素的父元素都是普通的父元素。\n    2. absolute绝对定位元素的父元素是离它最近的***非static定位元素***。\n    3. fixed固定定位元素的父元素是浏览器窗口（近似于body)。\n2. 找准width计算规则\n    1. absolute绝对定位元素的width:100%取值等于父元素的content值加上padding值(与border-width无关)。\n    2. fixed固定定位元素的width:100%等于浏览器窗口的width。\n    3. 除此之外所有元素的width:100%等于父元素的content值。\n上面两点可以确定好width值，然后元素本身会根据box-sizing属性来分配content，border以及padding。（margin-box浏览器支持有限）。\n\nwidth auto的小结\n1. block元素的width:auto会使widh尽可能大直至撑满父元素，inline-block元素width:auto会使width尽可能小直至包裹内容。\n\npadding和margin百分比小结\n1. 非绝对定位元素padding和margin百分比（包括padding-top    ，pading-bottom，margIn-top，margin-bottom）相对于父元素content-box的width值计算的。\n2. 绝对定位元素padding和margin百分比（包括padding-top，pading-bottom，margIn-top，margin-bottom）相对于最近非static定位父元素padding-box的width值计算的。\n\nborder-width不能设置百分比\n","tags":["width","百分比","auto"],"categories":["css"]},{"title":"vue中computed属性的理解","url":"/2019/11/02/vue中computed属性的理解/","content":"computed是vue中一个重要的属性-**计算属性**。\n## 基本用法：\n{% codeblock lang:js %}\n    computed: {\n        test:function(){\n            return this.param;\n        }\n    }\n{% endcodeblock %}\n\n## 进阶用法：\n{% codeblock lang:js %}\n    computed:{\n        test:{\n            get(){              //getter\n                return this.param;\n            },\n            set(val){           //setter\n                this.param = val;\n            }\n        }\n    }\n{% endcodeblock %}\n\n##我的理解：\ncomputed计算属性是在beforeCreate之后，created\n之前这个时间段内***初始化***的。当前***依赖的初始值***决定了计算属性的的初始值。同时计算属性的结果会被缓存，除非之后依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) \n在该实例范畴之外，则计算属性是不会被更新的。","tags":["vue生命周期"],"categories":["vue"]},{"title":"npm常用的命令","url":"/2019/10/30/npm常用的命令/","content":"最近常用到一些npm的命令，今天总结一下，方便以后查阅。\n使用npm，需要提前安装**node.js**。\n### 查询npm和node.js版本\n```\nnpm -v\nnode -v\n```\n\n### 列出npm所有的命令用法\n```\nnpm -l\nnpm <command> -h    //某条指令的详细说明\n```\n\n### 安装npm包\n```\nnpm i <package name> [ -g,-S,--save-dev]\nnpm install -g cnpm --registry=https://registry.npm.taobao.org   //安装国内淘宝镜像\n```\n\n### 卸载npm包\n```\nnpm un <package name> [ -g,-S,--save-dev]\n```\n\n### 升级npm包\n```\nnpm up <package name> [ -g,-S,--save-dev]\n```\n\n### 查看本地已安装的包\n```\nnpm ls [-g]\n```\n\n### 查看某个包在npm服务器上的版本信息\n```\nnpm info <package name>     //查看包在npm服务器上最新版本的详细信息 \nnpm view <package name> versions    //查看包在npm服务器上的所有版本号（仅显示版本号） \nnpm view <package name> version    //查看包在npm服务器上的最新版本号（仅显示版本号） \n```\n\n### 清空npm本地缓存\n```\nnpm cache clear      //当使用相同版本号发布新版本代码时，更新前需执行此命令\n```\n### 设置淘宝镜像\n`npm config set registry https://registry.npm.taobao.org`\n\n### 设置官方源\n`npm config set registry https://www.npmjs.org `\n","tags":["npm"],"categories":["前端"]},{"title":"host文件的作用和用法","url":"/2019/10/26/host文件的作用和用法/","content":"\n## Hosts 文件的工作方式\n\nWindow 系统中有个 Hosts 文件（没有后缀名）。\n我们访问网站时，首先要通过**DNS 服务器**把要访问的网络域名（XXX.com）解析成 IP 地址后，计算机才能对这个网络域名进行访问。如果对于每个域名请求我们都要等待 DNS 服务器解析并返回 IP\n信息，这样访问的效率就会降低。为了提高对经常访问的网络域名的解析效率，可以通过利用 Hosts 文件中建立域名和 IP 的映射关系来达到目的。\n根据 Windows 系统规定，在进行 DNS 请求以前，Windows 系统会先检查自己的 Hosts 文件中是否有这个网络域名映射关系。如果有则，调用这个 IP 地址映射，如果没有，再向已知的 DNS 服务器提出域名解析。也就是说**_Hosts 的请求级别比 DNS 高_**。\n\n---\n\n## Hosts 文件的语法\n\nHost 规定每段只能包括一个映射关系，也就是一个 IP 地址和一个与之有映射关系的主机名。\nIP 地址要放在每段的最前面，映射的 Host name(主机名)在 IP 后面，中间用空格分隔。注释可以以“#”分割后的文字来说明。\n\n```\ngrammar:\n       ip host-name\n127.0.0.1 localhost\n```\n\n---\n\n## Hosts 文件的用法\n\n1. 加快域名解析\n   对于要经常访问的网站，我们可以在 Hosts 中配置域名和 IP 的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出 IP，而不用请求网络上的 DNS 服务器。\n\n2. 方便局域网用户\n   在很多单位的局域网中，会有服务器提供给用户使用。局域网中一般很少架设 DNS 服务器，访问这些服务器时，要输入难记的 IP 地址。这对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在 Hosts 中建立 IP 映射，这样以后访问的时候，只要输入这个服务器的名字就行了。\n\n3. 屏蔽网站\n   现在有很多恶意网站。对于这些网站我们可以利用 Hosts 把该网站的域名映射到错误的 IP 或本地计算机的 IP，这样就可以达到屏蔽的目的。在 WINDOWS 系统中，约定 127.0.0.1 为本地计算机的 IP 地址, 0.0.0.0 是错误的 IP 地址。\n   例如下面的代码：\n\n```\n127.0.0.1  # 要屏蔽的网站A\n0.0.0.0  # 要屏蔽的网站B\n```\n\n4. 顺利连接系统\n   对于 Lotus 的服务器和一些数据库服务器，在访问时如果直接输入 IP 地址是不能访问的，只能输入服务器名才能访问。如果我们配置好 Hosts 文件，这样输入服务器名就能顺利连接了。\n\n---\n\n## Apache 中 vhost 的作用\n\nvhost 允许在同一个服务器中（或者计算机、主机）配置多个域名和端口。方法如下：\n\n1. 在 apache 配置文件 httpd.conf 中，新增端口 5000：\n\n```\n#Listen 12.34.56.78:80\nListen 80\nListen 5000\n```\n\n2. 在 D:\\xampp\\apache\\conf\\extra\\httpd-vhosts.conf 中，新增端口解析：\n\n```\n<VirtualHost *:5000>\n    ServerAdmin webmaster@tp5.com\n    DocumentRoot \"D:/XAMPP/htdocs/tp5/public\"\n    DocumentRoot \"D:/XAMPP/htdocs/tp5/public\"\n    ServerName tp5.com\n    ErrorLog \"D:/XAMPP/htdocs/tp5/public/access.log\"\n    CustomLog \"D:/XAMPP/htdocs/tp5/public/access.log\" common\n</VirtualHost>\n```\n\n### vhost 配置语法\n\n1. <VirtualHost [ip:端口]> 指定虚拟主机所使用的 IP 地址，端口或域名（如果 web 服务器上有多个 IP，就可以制定某个 IP 的某个端口是哪个主机）\n2. ServerAdmin 管理员邮箱（Apache 本地服务器中一般设成 webmaster@[绑定的域名]）\n3. DocumentRoot 网站根目录（地址两端加引号,必填）\n4. ServerName 绑定的域名 （必填）\n5. ServerAlias 要绑定的虚拟主机的别名。（选填，如有多个域名，中间以空格分隔。支持*，?两种通配符，比如 *.abc.com，表示任意一个 abc.com 的二级域名都可访问。）\n6. ErrorLog 错误日志目录 （选填）\n7. CustomLog 用户日志目录 （选填）\n   **_Apache 在接受到请求时,如果没有匹配到对应的 ip 端口和绑定域名，就会默认第一个 VirtualHost 起作用。_**\n\n---\n\n## host 和 vhost 的区别\n\n如图：\n![简单流程图](/images/host1.png)\n\nhost 是本地计算机中**_通过请求域名来解析 ip_**的文件，vhost 是 web 服务器中通过域名和 ip 端口来确**_定 web 服务器分发内容的目录_**的文件。\n","tags":["host","Apache","vHost"],"categories":["服务端"]},{"title":"Promise的理解","url":"/2019/10/25/Promise的理解/","content":"## Promise\nPromise对象是解决异步问题的一种方法。它的基本用法如下：\n{% codeblock lang:js %}\n    const promise = new Promise((resolve,reject) => {\n        ...(async code)         //一段异步代码     pending状态\n        if(succeed){            //fulfilled状态\n            resolve();\n        }else{                  //rejected 状态\n            reject();\n        }\n    })\n    promise.then(resolve,reject).then(...)\n{% endcodeblock %}\n它有以下特点：\n1. new promise参数中的函数会立即执行，等同于同步代码。\n2. promise对象的状态不受外界影响，而且状态一旦改变就不会再变。它有三种状态：pending（进行中），fulfilled（已成功），rejected（已失败）。在new promise中执行resolve()时，状态由pennding变成fulfilled，执行reject()时，状态会由pending变成rejected.\n3. 当promise状态改变就会触发then()中的回调函数，这个回调函数属于microTask。优先级高于macroTask但低于同步代码。\n\n<!-- ## Promise常用api -->"},{"title":"hexo的使用","url":"/2019/10/24/hexo的使用/","content":"## 安装\nhexo是一个基于node.js的博客框架。安装hexo，需要提前安装下列application:\n\n1. node.js(version不低于8.6，建议使用10.0+版本)； \n2. git （用于部署博客至线上）\n\n上述应用安装完成后，便可以通过npm安装hexo：\n{% codeblock lang:npm %}\n    npm install hexo-cli -g\n{% endcodeblock %}\n\n## hexo常用命令\n### 1. hexo init <new folder>\n在指定的<new folder>文件夹中新建一个hexo项目。如果省略<new folder>，便会在当前文件夹先建一个项目。\n\"hexo init\"常常搭配下面的代码来初始化项目：\n{% codeblock lang:npm %}\n    hexo init <folder>\n    cd <folder>\n    npm install\n{% endcodeblock %} \n\n### 2. hexo new [layout](title)\n这个命令可以新建一个[post,page,draft]。title是文件名。\n**新建的draft草稿不会被渲染，用于存储未完成的文章。**当需要将草稿变成文章时，可以手动将.md直接移动到_posts文件夹中，也可以使用“hexo publish [type](文件名(不带.md))”指令。手动将.md移动到_drafts文件夹可以使文章变成草稿。\n\n### 3. hexo genetate\n将markdown文本生成静态文件,可简写为hexo g 。\n{% codeblock lang:npm %}\n    hexo g -d       //生成静态文件后立即部署\n    hexo g -f       //清空public文件夹，重新生成静态文件\n{% endcodeblock %}\n\n### 4. hexo server\n启动服务器,可简写为 hexo s 。可以通过http://localhost:4000/访问。\n{% codeblock lang:npm %}\n    hexo s -p   //重设服务器端口\n    hexo s -s   //只使用静态文件\n{% endcodeblock %}\n\n### 5. hexo deploy\n部署博客网站，可简写为hexo d 。\n{% codeblock lang:npm %}\n    hexo d -g   //先生成静态文件，再部署网站\n{% endcodeblock %}\n\n### 6. hexo clean \n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也**不生效**，可能需要运行该命令。\n\n### 7. hexo list <type>\n列出所有<type>类型的文件。type包括[post,page,draft,tag,category,route]。\n\n### 8. hexo --debug\n在终端中显示调试信息并记录到 debug.log。当碰到问题时，可以用调试模式重新执行一次，并提交调试信息到 GitHub。\n\n在hexo中，source文件夹是放置几乎所有编辑文件的地方。在source文件夹中，如果有引入的第三方代码，例如：jquery，一定要加入到skip_render中。否则可能出现意想不到的错误。\n","tags":["hexo"],"categories":["前端"]},{"title":"vue和vuec的安装和使用","url":"/2019/10/21/vue和vuec的安装和使用/","content":"## 安装vue\n这段时间，我在学习vue的使用。安装vue有三种方式：\n1. CDN方式：直接使用 `<script>` 标签引用vue；\n{% codeblock lang:html %}\n    <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>  //引用最新版本vue\n    <script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.0\"></script>        //引用具体版本vue\n{% endcodeblock %} \n\n2. npm安装：\n{% codeblock lang:js %}\n   npm install vue  //安装最新稳定版\n   npm install -g cnpm --registry=https://registry.npm.taobao.org //可以安装npm淘宝镜像，提高安装速度 \n{% endcodeblock %}\n\n3. 安装vue-cli构建工具：\n   a. 卸载旧版本vuec\n{% codeblock lang:js %}\n    npm uninstall vue-cli -g  //vuec 2.0前称作vue-cli, 3.0+后称作@vue/cli\n{% endcodeblock %}\n    \n   b. 安装新版本vuec\n{% codeblock lang:js %}\n    npm install @vue/cli -g \n{% endcodeblock %}   \n<br>\n---\n## vuec使用\n1. 新建vue项目\n{% codeblock lang:js %}\n    vue create project_name\n//  or \n//  vue ui     进入vue gui管理界面\n{% endcodeblock %}\n项目名称不能出现**大写字母或者驼峰形式**。\n\n2. 进入安装目录，并运行。\n{% codeblock lang:js %}\n    cd project_name\n    npm install\n    npm run serve\n{% endcodeblock %} \n<br>\n---\n## element-ui的安装及使用\n1. npm安装使用\n{% codeblock lang:js %}\n    npm i element-ui -S\n{% endcodeblock %}\n在vuec创建项目中的main.js文件中写入以下代码：\n{% codeblock lang:js %}\n    import Vue from 'vue';\n    import ElementUI from 'element-ui';\n    import 'element-ui/lib/theme-chalk/index.css';\n    import App from './App.vue';\n    \n    Vue.use(ElementUI);\n    \n    new Vue({\n      el: '#app',\n      render: h => h(App)\n    });       \n{% endcodeblock %}\n\n2. CDN引用\n{% codeblock lang:html %}\n<!-- 引入样式 -->\n<link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\">\n<!-- 引入组件库 -->\n<script src=\"https://unpkg.com/element-ui/lib/index.js\"></script>\n{% endcodeblock %}\n\n3. 安装vue-cli-plugin-element\n这个方法要求@vue/cli 3.0+ 。安装的代码如下：\n{% codeblock lang:npm %}\n    vue create <my-app>\n    cd <my-app>\n    vue add element\n{% endcodeblock %}   \n然后根据提示，插件会自动导入element-ui。\n\n---\n\n## axios的安装\n1. 通用的安装方法：\n`npm install axios`\n2. vue-axios的安装和用法：\n`npm install --save axios vue-axios `\n**在main.js中引入**\n```\n   import Vue from 'vue'\n   import axios from 'axios'\n   import VueAxios from 'vue-axios'\n   \n   Vue.use(VueAxios, axios)\n```\n**你可以这样使用它：**\n```\nVue.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.$http.get(api).then((response) => {\n  console.log(response.data)\n})\n```\n\n      ","tags":["vue","vuec"],"categories":["前端"]},{"title":"html中script标签引用多个js文件的执行问题","url":"/2019/10/14/html中script引用多个js文件的执行问题/","content":"\n`<script>`标签可以实现多个js文件的同步引用。如下：\n{% codeblock lang:html %}\n\t\t<head>\n\t\t\t\t<script type=\"text/javascript\" src=\"one.js\"></script>\n\t\t\t\t<script type=\"text/javascript\" src=\"two.js\"></script>\n\t\t\t\t<script type=\"text/javascript\" src=\"three.js\"></script>\n\t\t</head>\n{% endcodeblock %}\n\n1. **js文件按顺序加载，执行**；\n2. **各个js文件中的全局变量和全局函数可以被其他js文件调用**；\n3. **较早执行的js文件不能调用较晚加载的js文件中的变量和函数。例如：\"two.js\"不能调用\"three.js\"中的变量和函数；**","tags":["script标签"],"categories":["js"]},{"title":"Git error cannot spawn ssh No such file or directory的一个解决办法","url":"/2019/10/14/Git error解决办法/","content":"\n今天在hexo中，部署博客到github上时出现一个错误：\n **Git error** cannot spawn ssh No such file or directory \n\n这个错误最后发现是**ssh**没有加入到**环境变量**中，将**`\"D:\\Git\\usr\\bin\\ssh.exe\"`**加入到**环境变量**后，问题解决。\n\n","categories":["git"]},{"title":"background-size失效问题","url":"/2019/07/09/background-size失效问题/","content":"\n今天写代码时遇到一个问题，发现background-size属性无效。代码如下：\n\n{% codeblock lang:css %}\n\t.icon{\n\t\tbackground-size:12px 12px; \n\t\tbackground: url('assets/img/decrease_1@2x.png');\n\t    }\n{% endcodeblock %}\n\n后来发现原因是，background是一个*组合属性*。它本身包含了background-size属性，默认值是auto。如果把background放在background-size后面，那么background-size会被覆盖为auto，这样就导致background-size设置失效。正确的写法如下：\n\n{% codeblock lang:css %}\n\t.icon{\n\t\tbackground: url('assets/img/decrease_1@2x.png');\n\t\tbackground-size:12px 12px; \n\t    }\n{% endcodeblock %}\n\n举一反三，以后遇到其他的*组合属性*一定要注意它出现的*位置*。\n\n","tags":["background"],"categories":["css"]},{"title":"vue项目中遇到的问题","url":"/2019/07/02/vue项目中遇到的问题/","content":"\n### 利用v-if来避免异步调用json数据延迟报错；\n\n**_代码如下：_**\n\n{% codeblock lang:html %}\n\t<template>\n\t    <div class='header'>\n\t        <div class=\"support\">\n\t            <span class=\"text\">\n\t            \t  {% raw %}{{seller.supports[0].description}}{% endraw %}\n\t            </span>\n\t        </div>\n\t    </div>\n\t</template>\n{% endcodeblock %}\n\n*seller*是在vue生命周期函数create()异步获取的，代码如下：\n\n{% codeblock lang:js %} \n\tcreated:function{\n\t  this.$http.get('/api/seller').then((response) => {\n\t    let res = response.body;\n\t    console.log(res);\n\t    if(res.errno === ERR_OK){\n\t      this.seller = res.data;\n\t    }\n\t  });\n\t}\n{% endcodeblock %}\n\n如果网络有延迟，当dom开始渲染时，seller还没有返回数据，浏览器就会报错。如下图所示：\n![浏览器报错](/images/Snipaste1.png)\n\n***解决办法：***\n通过添加v-if来限定dom渲染的时机。添加后代码如下：\n{% codeblock lang:html %}\n\t<template>\n\t    <div class='header'>\n\t        <div class=\"support\" v-if='seller.supports'>\n\t            <span class=\"text\">\n\t            \t  {% raw %}{{seller.supports[0].description}}{% endraw %}\n\t            </span>\n\t        </div>\n\t    </div>\n\t</template>\n{% endcodeblock %}\n\n---\n\n\n### 在less中如何实现字符串拼接\n#### 如何引入外部less文件（or css文件)\n引入css文件一般有两种方法：*@import url()*和*link*\n@import url()中url可以直接省略,例如：\n\n{% codeblock lang:css %}\n\t<style lang=\"less\" scoped=\"\">\n\t\t/*one way*/\n\t\t@import url('../index.less');\n\n\t\t/* the other way*/\n\t\t@import \"../index.less\";\n\t</style>\n{% endcodeblock %}\n\n但是，省略url时，@import后面路径必须用*双引号*，在vue component中，使用单引号可能导致引用css失败。\n\n{% codeblock lang:html %} \n<style lang=\"less\" scoped=\"\">\n\t<!-- 在vue中这种方式可能导致引用css失败 -->\n\t@import '../index.less';  \n</style>\n{% endcodeblock %}\n\n#### 在less中如何实现字符串拼接\n在less中，不可以类似js用‘+’表示字符串拼接。需要利用less中的变量的*可变插值*来拼接字符串；\n\n{% codeblock lang:css %}\n.bg(@url){\n\t@bg_url:'~@/assets/img/@{url}@2x.png';\n}\n{% endcodeblock %}\n\n这其中@{url}就是可变插值的用法。less变量的可变插值可以用在*选择器名称，属性名称，URL和@import语句*这些地方。\n\n#### error: ~/.vuerc may be outdated. Please delete it and re-run vue-cli in manual mode\n最近，尝试使用@vue/cli@4.0.5来构建项目，但是编译老是出错。不得已换回了@3.0版本。降低版本后，vue create <new project>会报错。\n![vue error](/images/vueError2.png)\n**解决办法：**\nwindows系统中'C:\\Users\\Administrator'里面有个.vuerc 文件。手动删除后，重新创建项目，问题解决。","tags":["vue"],"categories":["前端"]},{"title":"外边距叠加","url":"/2019/06/19/外边距margin叠加/","content":"在*普通文档流*中，*块框 垂直的*两个外边距margin*直接接触*会发生叠加，形成一个外边距。 叠加后的margin取两者中的*较大值*。\n\n### 一、外边距叠加需要的条件：\n\n1. 普通文档流；\t\t\t\t\t\t\t\t\t\t\t\t\n2. 块框；\n3. 垂直方向上；   \n4. 外边距margin直接接触；\n\n所以在行内框，浮动框或者绝对定位框之间的外边距并不会叠加,水平方向上的margin-left和margin-right也不会发生叠加。\n\n### 二、外边距叠加具体的几种情况：\n1. 一个元素出现在另一个元素*上面*时，垂直外边距会发生叠加；如下图演示：\n{% iframe '/pages/margin-demo1/' 100% 300px %}\n\n2. 一个元素出现在另一个元素*内部*时，垂直外边距会发生叠加；如下图演示：\n{% iframe '/pages/margin-demo2/' 100% 350px %}\n\n3. 当一个元素border,padding,height同时为0时，*元素本身*的margin-top和margin-bottom也会发生叠加；如下图演示：\n{% iframe '/pages/margin-demo3/' 100% 210px %}\n\n### 内边距*padding*不会发生叠加\n\n\n\n\n\n","tags":["外边距"],"categories":["css"]}]