---
title: 前端鉴权总结
date: 2021-01-08 11:17:13
categories: 前端
tags: ["鉴权", "token", "session-cookie"]
---

我们在访问网站时不可避免会遇到登录的问题，这归根到底就是访问权限的问题。前端鉴权方案主要有以下几种：

1. HTTP Basic Authentication：现在用的较少，主要用在一些较老的项目中。
2. session-cookie：依赖 cookie,只适用于 web 系统。
3. token: 目前主流鉴权方式，适用于多种客户端（浏览器、app 等）。
4. OAuth：第三方授权，方便快捷是以后的趋势。

## 一、HTTP Basic Authentication

顾名思义，这种鉴权方式叫做 http 基本认证。
![HTTP Basic Authentication 鉴权流程](/images/http_basic_authentication.png)

### 鉴权流程

1. 客户端发送 http 请求给服务器，服务器验证有无访问权限；
2. 无访问权限时，服务器**返回 401**，客户端接收到 401 响应自动弹出登录验证对话框；
3. 用户输入用户名和密码后，客户端将用户名和密码以 `name: password` 的形式采用 `base64` 编码方式编码，并放入请求头，再次发送请求；
4. 服务器校验成功，返回数据。

### 应用场景

这种鉴权方式的使用简单但安全性较差。配合 https 可以在**内部网络**，或者对安全要求不是很高的网络中使用，比较适合**只需要一个特定密码**就可以访问的场景。

## 二、session-cookie

session 是此方案区别其他方式的核心。cookie 只是信息传递的**载体**。整个验证流程如下：

1. 浏览器登录时发送账号密码到服务端，服务端查询 User 库，校验用户
1. 校验成功后，服务端把用户**登录状态存到 session 中**，同时生成一个对应的 sessionId 由登录接口返回，把 **sessionId 存储到 cookie**上
1. 浏览器再次发送业务请求时，带有 sessionId 的 **cookie 会自动添加到 Request Header 中**发送到服务端
1. 服务端通过 sessionId 在 session 库中查询，**校验登录状态**
1. 检验成功后，服务端**进行业务处理并返回结果**
   ![session-cookie 鉴权流程](/images/session_cookie.jpg)

### session 的存储方式

1. 直接通过变量引用存储在**服务器本地内存**，缺点是服务器重启后，session 就会消失。
2. 存储在**普通数据库**。缺点是性能不高。
3. （`推荐`）存储在**Redis**(内存型数据库)中。**访问快，可持久存储**。

### 分布式 session

大型应用的网络请求一般会采用负载均衡的优化方式。当业务请求和登录请求到达的服务器不是同一个时，普通的 session-cookie 鉴权就会出现 session 验证失败的问题！通常的解决方案如下：

1. （`推荐`）从「存储」的角度来看，把 session 集中存储在独立的 Redis 或普通数据库中，就可以把 session 都存到一个库里。
2. 从「分布」的角度来看，让相同 IP 的请求在负载均衡时都发送到同一台服务器上。以 nginx 为例，可以配置 ip_hash 来实现。

### session-cookie 登录状态的有效期

登录状态一般需要设置一定的有效期，采用 session-cookie 方案，一般可以从两个方面设置有效期：

1. 在 cookie 上设置。服务器返回 sessionId 是通过 **set-cookie** 响应头在浏览器上种下 cookie。此时就可以通过 cookie 属性 **Expires / Max-Age** 设置过期时间。

```
Set-Cookie: sid=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure;HttpOnly;path=/blog;Domain=baidu.com;Max-Age=240000
```

2. 在 session 上设置。服务器可以设置一段时间后**删除 session**，sessionId 校验查询不到 对应的 session 就相当于登录状态失效了。

## 三、token（`推荐`）

session-cookie 方案通常是基于 cookie 的。而 **cookie 只有浏览器才有**，对于 app 应用，此方案有天生的缺陷。而且 session-cookie 方案**需要内存存储** session 和数据库查询, 加大了服务器负担。为了解决这些问题，token 鉴权方案应势而生。

1. 浏览器登录时发送账号密码到服务端，服务端查询 User 库，校验用户
1. 校验成功后获得用户信息，把**用户信息和 token 配置**编码加密生成 token，通过 cookie set 到浏览器（或者通过**响应头**）
1. 用户再次请求业务接口时，通过 cookie 携带 token（或者通过**请求头**）发送到服务端
1. 服务器校验 token 有效性，进行业务逻辑处理并返回数据
   ![token 鉴权](/images/token.jpg)
   ![更复杂的 token 鉴权（access token and refresh token）](/images/access_and_refresh_token.jpg)

### JWT（json web token）

token 里面包含了一些用户信息，所以安全性就有一定的要求。token 加密的方法和信息传递的形式有很多种，其中业内采用较多的标准就是 jwt。它分为三部分，第一部分 header 是加密算法声明，第二部分 payload 是用户信息和一些数据，第三部分 signature 是签名。
![jwt](/images/jwt.jpg)

## 四、OAuth 第三方登录

OAuth 2.0 是**目前最流行**的授权机制，用来授权第三方应用，获取用户数据。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的可进入令牌（token），用来代替密码，供第三方应用使用。OAuth2.0 有四种授权方式：

1. 授权码 code 式 （`推荐`）
2. 隐藏式 （忽略请求授权码步骤，适用**纯前端应用**）
3. 密码式 （只有高度可信任应用才使用，不安全，`不推荐`）
4. 凭证式 （适用于没有前端的**命令行应用**）

   ![Oauth 第三方登录授权码方式](/images/oauth.png)

现在我们主要总结一下 **授权码式** 的授权逻辑：

1. 首先我们需要在 B 网站 （QQ、微信或者 github 等）上登记 A 网站信息，主要包括 A 网站的**homepage_url 和 redirect_uri** 等信息。登记后，B 网站会返回 **client ID 和 client secret** 用于后续请求的身份验证。
2. 当我们登录 A 网站时，选择第三方授权。浏览器会携带**client_id、redirect_uri**等信息跳转到 B 网站授权页面，B 网站要求我们登录验证信息。（扫码或者输入密码）
3. 用户登录 B 网站后，B 网站校验用户信息并携带 `code` 重定向到 **redirect_uri**
4. A 网站后端接收到 code 后，再次携带 grant_type、client_id 、client_secret、code、redirect_uri 等信息向 B 网站服务器**请求 token**
5. B 网站后端校验 code 等信息，再次向 redirect_uri 返回**access token 和 refresh token**
6. A 网站服务器拿到 token 后就会根据自身需求处理相关业务逻辑或者重定向到 A 网站首页

## 参考文章：

- [前端鉴权的兄弟们：cookie、session、token、jwt、单点登录](https://zhuanlan.zhihu.com/p/281414244)
- [OAuth 2.0 的一个简单解释](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)
- [OAuth 2.0 的四种方式](http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html)
- [GitHub OAuth 第三方登录示例教程](http://www.ruanyifeng.com/blog/2019/04/github-oauth.html)
