---
title: 算法和数据结构入门
date: 2020-03-15 00:19:50
categories: 算法
tags: ['算法','数据结构']
---
## 算法
### 算法的特点
1. 输入；
2. 输出；
3. 明确性；
4. 有限性；
5. 有效性（可行性）

### 伪代码和流程图
1. 伪代码
伪代码（Pseudocode）是一种非正式的，类似于英语结构的，用于描述算法的语言。使用伪代码使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java等）实现。
2. 流程图
流程图是使用图形表示算法的一种方式。其中圆角矩形表示开始和结束，矩形表示正常的运算，棱形表示判断语句，箭头表示运算顺序。

### 常见的算法思想
1. 分治法（前端最常用的算法思想）
2. 动态规划法
3. 贪婪法
4. 线性规划法
5. 精并法

### 常用的排序算法
1. 冒泡排序-两两比较，视情况而定交换位置。时间复杂度为O(n^2)
2. 选择排序-依次选择最大或者最小的放在最前面
3. 插入排序-每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。类似于‘起扑克牌’
5. 快速排序法-通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序
4. 计数排序法-借助hash表的特殊的桶排序，空间换换时间。复杂度Ο(n+k)‘类似于玩空当接龙’
6. 基数排序
在[visualgo.net](https://visualgo.net)上能可视化排序算法的实现过程。

## 数据结构
### 数据结构
数据结构(data structure)是**带有结构特性的数据元素的集合**。数据结构是计算机存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关，**算法离不开数据结构**，在规划算法前，要先想好**数据结构**。js中简单的数据结构包括**数组和对象。**

### 常见的几种数据结构
1. hash（哈希表）
散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。在js中，一个对象就可以称为一个hash table。
在桶排序和计数排序中就用到了hash表。

2. queue（队列）
queue是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为**队尾**，进行删除操作的端称为**队头**。队列中没有元素时，称为**空队列**。
特点：
    1. 先进先出
    2. js中可以用数组实现（push，shift）
    3. 类似于‘排队，先排队的在前面就会先出去，前面的地方就是**队头**，后面的地方就是**队尾**’

3. stack（栈）
stack在计算机科学中是限定仅在**表尾**进行插入或删除操作的线性表。进行删除和插入的一端称**栈顶**，另一端称**栈底**。插入一般称为**进栈**，删除则称为**退栈**。 栈也称为**后进先出表**。
特点：
    1. 后进先出
    2. js中可以用数组实现（push，pop）
    3. 类似于‘往桶里放东西，后放进去的在上面就会被先拿出来，桶的的上方就是**栈顶**，底部就是**栈底**’

4. 链表
链表是一种非连续、非顺序的数据结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成。**每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。**
    1. 线性表的缺点就是**删除元素麻烦**，链表是非线性表它的缺点是**查询元素麻烦**。
    2. 链表一般包括head和node

5. 树
树是一种数据结构，它是由n（n>=0）个有限结点组成一个具有层级结构的集合。每个结点有零个或多个子结点；没有父结点的结点称为**根结点**，没有子结点的结点称为**叶子结点**。**结点的层次**：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。一棵树中所有结点的层次的最大值称为这棵树的**深度**。
    1. 二叉树：每个节点最多含有两个子树的树称为二叉树；
    2. 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。
    3. 完全二叉树：完全二叉树是由满二叉树而引出来的。满二叉树最后一层的最后的结点**连续的**丢失掉形成的树。
    4. 满二叉树和完全二叉树可以用js数组实现，其他的树需要用链表实现。

6. 堆（heap）
堆是特殊的完全二叉树。堆中**某个节点的值总是不大于或不小于其父节点的值**。当根节点的值是最大的值时，这样的堆称为**最大堆**。当根节点的值最小时，称为**最小堆**。
**堆排序**就是兄弟节点和父节点比较取最大值作为新的父节点，不断的构成最大堆或者最小堆，由此达到排序目的的算法。